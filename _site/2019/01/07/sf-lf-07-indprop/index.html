<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="google-site-verification" content="xBT4GhYoi5qRD5tr338pgPM5OWHHIDR6mNg1a3euekI" />
    <meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover">
    <meta name="description" content="关于程序与设计、黑客与画家 | 黄玄，Web & Mobile Lover，Software Engineer，UX Designer | 这里是 @Hux黄玄 的个人博客，与你一起发现更大的世界。">
    <meta name="keywords"  content="黄玄, Hux黄玄, Hux, 鬼栈, huxpro, @huxpro, 黄玄的博客, Hux Blog, 博客, 个人网站, 互联网, Web, JavaScript, 前端, 设计">
    <meta name="theme-color" content="#000000">
    
    <!-- Open Graph -->
    <meta property="og:title" content="「SF-LC」7 Ind Prop - lxd的博客 | lxd Blog">
    
    <meta property="og:type" content="article">
    <meta property="og:description" content="Inductively Defined Propositions

">
    
    <meta property="article:published_time" content="2019-01-07T00:00:00Z">
    
    
    <meta property="article:author" content="Hux">
    
    
    <meta property="article:tag" content="LF (逻辑基础)">
    
    <meta property="article:tag" content="SF (软件基础)">
    
    <meta property="article:tag" content="Coq">
    
    <meta property="article:tag" content="笔记">
    
    
    <meta property="og:image" content="http://localhost:4000/img/avatar-hux-ny.jpg">
    <meta property="og:url" content="http://localhost:4000/2019/01/07/sf-lf-07-indprop/">
    <meta property="og:site_name" content="lxd的博客 | lxd Blog">
    
    <title>「SF-LC」7 Ind Prop - lxd的博客 | lxd Blog</title>

    <!-- Web App Manifest -->
    <link rel="manifest" href="/pwa/manifest.json">

    <!-- Favicon -->
    <link rel="shortcut icon" href="/img/favicon.ico">
    
    <!-- Canonical URL -->
    <link rel="canonical" href="http://localhost:4000/2019/01/07/sf-lf-07-indprop/">

    <!-- Bootstrap Core CSS -->
    <link rel="stylesheet" href="/css/bootstrap.min.css">

    <!-- Custom CSS -->
    <link rel="stylesheet" href="/css/hux-blog.min.css">

    <!-- Custom Fonts -->
    <!-- <link href="http://maxcdn.bootstrapcdn.com/font-awesome/4.3.0/css/font-awesome.min.css" rel="stylesheet" type="text/css"> -->
    <!-- Hux change font-awesome CDN to qiniu -->
    <link href="//cdnjs.cloudflare.com/ajax/libs/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" type="text/css">


    <!-- HTML5 Shim and Respond.js IE8 support of HTML5 elements and media queries -->
    <!-- WARNING: Respond.js doesn't work if you view the page via file:// -->
    <!--[if lt IE 9]>
        <script src="https://oss.maxcdn.com/libs/html5shiv/3.7.0/html5shiv.js"></script>
        <script src="https://oss.maxcdn.com/libs/respond.js/1.4.2/respond.min.js"></script>
    <![endif]-->

    <!-- ga & ba script hoook -->
    <script></script>
</head>


<!-- hack iOS CSS :active style -->
<body ontouchstart="">

    <!-- Navigation -->

<nav class="navbar navbar-default navbar-custom navbar-fixed-top invert">

    <div class="container-fluid">
        <!-- Brand and toggle get grouped for better mobile display -->
        <div class="navbar-header page-scroll">
            <button type="button" class="navbar-toggle">
                <span class="sr-only">Toggle navigation</span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
            </button>
            <a class="navbar-brand" href="/">lxd's Blog</a>
        </div>

        <!-- Collect the nav links, forms, and other content for toggling -->
        <div id="huxblog_navbar">
            <div class="navbar-collapse">
                <ul class="nav navbar-nav navbar-right">
                    <li>
                        <a href="/">Home</a>
                    </li>
                    
                    
                    
                    
                    <li>
                        <a href="/about/">About</a>
                    </li>
                    
                    
                    
                    <li>
                        <a href="/archive/">Archive</a>
                    </li>
                    
                    
                    
                    
                    
                    
                    
                    
                    
                    
                    
                    
                    
                    
                </ul>
            </div>
        </div>
        <!-- /.navbar-collapse -->
    </div>
    <!-- /.container -->
</nav>
<script>
    // Drop Bootstarp low-performance Navbar
    // Use customize navbar with high-quality material design animation
    // in high-perf jank-free CSS3 implementation
    var $body   = document.body;
    var $toggle = document.querySelector('.navbar-toggle');
    var $navbar = document.querySelector('#huxblog_navbar');
    var $collapse = document.querySelector('.navbar-collapse');

    var __HuxNav__ = {
        close: function(){
            $navbar.className = " ";
            // wait until animation end.
            setTimeout(function(){
                // prevent frequently toggle
                if($navbar.className.indexOf('in') < 0) {
                    $collapse.style.height = "0px"
                }
            },400)
        },
        open: function(){
            $collapse.style.height = "auto"
            $navbar.className += " in";
        }
    }

    // Bind Event
    $toggle.addEventListener('click', function(e){
        if ($navbar.className.indexOf('in') > 0) {
            __HuxNav__.close()
        }else{
            __HuxNav__.open()
        }
    })

    /**
     * Since Fastclick is used to delegate 'touchstart' globally
     * to hack 300ms delay in iOS by performing a fake 'click',
     * Using 'e.stopPropagation' to stop 'touchstart' event from 
     * $toggle/$collapse will break global delegation.
     * 
     * Instead, we use a 'e.target' filter to prevent handler
     * added to document close HuxNav.  
     *
     * Also, we use 'click' instead of 'touchstart' as compromise
     */
    document.addEventListener('click', function(e){
        if(e.target == $toggle) return;
        if(e.target.className == 'icon-bar') return;
        __HuxNav__.close();
    })
</script>


    <!-- Image to hack wechat -->
<!-- <img src="/img/icon_wechat.png" width="0" height="0"> -->
<!-- <img src="/img/home-bg.jpg" width="0" height="0"> -->

<!-- Post Header -->



<style type="text/css">
    header.intro-header{
        position: relative;
        background-image: url('/img/home-bg.jpg');
        background: ;
    }

    
</style>

<header class="intro-header style-text" >

    <div class="header-mask"></div>
    
    <div class="container">
        <div class="row">
            <div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1">
                <div class="post-heading">
                    <div class="tags">
                        
                        <a class="tag" href="/archive/?tag=LF+%28%E9%80%BB%E8%BE%91%E5%9F%BA%E7%A1%80%29" title="LF (逻辑基础)">LF (逻辑基础)</a>
                        
                        <a class="tag" href="/archive/?tag=SF+%28%E8%BD%AF%E4%BB%B6%E5%9F%BA%E7%A1%80%29" title="SF (软件基础)">SF (软件基础)</a>
                        
                        <a class="tag" href="/archive/?tag=Coq" title="Coq">Coq</a>
                        
                        <a class="tag" href="/archive/?tag=%E7%AC%94%E8%AE%B0" title="笔记">笔记</a>
                        
                    </div>
                    <h1>「SF-LC」7 Ind Prop</h1>
                    
                    <h2 class="subheading">Logical Foundations - Inductively Defined Propositions (归纳定义命题)</h2>
                    <span class="meta">Posted by Hux on January 7, 2019</span>
                </div>
            </div>
        </div>
    </div>
</header>






<!-- Post Content -->
<article>
    <div class="container">
        <div class="row">

    <!-- Post Container -->
            <div class="
                col-lg-8 col-lg-offset-2
                col-md-10 col-md-offset-1
                post-container">

                <!-- Multi-Lingual -->
                

				<h2 id="inductively-defined-propositions">Inductively Defined Propositions</h2>

<h3 id="the-3rd-way-to-state-evenness">The 3rd way to state Evenness…</h3>

<p>Besides:</p>

<div class="language-coq highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
</pre></td><td class="rouge-code"><pre><span class="k">Theorem</span><span class="w"> </span><span class="no">even_bool_prop</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="err">∀</span><span class="no">n</span><span class="o">,</span><span class="w">
  </span><span class="no">evenb</span><span class="w"> </span><span class="no">n</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="no">true</span><span class="w"> </span><span class="err">↔</span><span class="w"> </span><span class="err">∃</span><span class="no">k</span><span class="o">,</span><span class="w"> </span><span class="no">n</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="no">double</span><span class="w"> </span><span class="no">k</span><span class="pi">.</span><span class="w">
 </span><span class="c">(*bool*)</span><span class="w">                 </span><span class="c">(*prop*)</span><span class="w">
</span></pre></td></tr></tbody></table></code></pre></div></div>

<p>we can write an <em>Inductive definition</em> of the <code class="highlighter-rouge">even</code> property!</p>

<h3 id="inference-rules">Inference rules</h3>

<p>In CS, we often uses <em>inference rules</em></p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
</pre></td><td class="rouge-code"><pre>                    ev n
---- ev_0       ------------ ev_SS
ev 0            ev (S (S n))
</pre></td></tr></tbody></table></code></pre></div></div>

<p>and <em>proof tree</em> (i.e. evidence), there could be multiple premieses to make it more tree-ish.</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
</pre></td><td class="rouge-code"><pre>---- ev_0
ev 0
---- ev_SS
ev 2
---- ev_SS
ev 4
</pre></td></tr></tbody></table></code></pre></div></div>

<p>So we can literally translate them into a GADT:</p>

<h3 id="inductive-definition-of-evenness">Inductive Definition of Evenness</h3>

<div class="language-coq highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
</pre></td><td class="rouge-code"><pre><span class="k">Inductive</span><span class="w"> </span><span class="no">even</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="no">nat</span><span class="w"> </span><span class="err">→</span><span class="w"> </span><span class="kr">Prop</span><span class="w"> </span><span class="p">:=</span><span class="w">
  </span><span class="o">|</span><span class="w"> </span><span class="no">ev_0</span><span class="w">  </span><span class="p">:</span><span class="w"> </span><span class="no">even</span><span class="w"> </span><span class="mi">0</span><span class="w">
  </span><span class="o">|</span><span class="w"> </span><span class="no">ev_SS</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="err">∀</span><span class="no">n</span><span class="o">,</span><span class="w"> </span><span class="no">even</span><span class="w"> </span><span class="no">n</span><span class="w"> </span><span class="err">→</span><span class="w"> </span><span class="no">even</span><span class="w"> </span><span class="o">(</span><span class="no">S</span><span class="w"> </span><span class="o">(</span><span class="no">S</span><span class="w"> </span><span class="no">n</span><span class="o">)).</span><span class="w"> 

</span><span class="k">Check</span><span class="w"> </span><span class="no">even_SS</span><span class="pi">.</span><span class="w">
</span><span class="c">(* ==&gt; : forall n : nat, even n -&gt; even (S (S n)) *)</span><span class="w">
</span></pre></td></tr></tbody></table></code></pre></div></div>

<p>There are two ways to understand the <code class="highlighter-rouge">even</code> here:</p>

<h3 id="1-a-property-of-nat-and-two-theorems-intuitively">1. A Property of <code class="highlighter-rouge">nat</code> and two theorems (Intuitively)</h3>

<blockquote>
  <p>the thing we are defining is not a <code class="highlighter-rouge">Type</code>, but rather a function <code class="highlighter-rouge">nat -&gt; Prop</code> — i.e., a property of numbers.</p>
</blockquote>

<p>we have two ways to provide an evidence to show the <code class="highlighter-rouge">nat</code> is <code class="highlighter-rouge">even</code>, either or:</p>
<ol>
  <li>it’s <code class="highlighter-rouge">0</code>, we can immediately conclude it’s <code class="highlighter-rouge">even</code>.</li>
  <li>for any <code class="highlighter-rouge">n</code>, if we can provide a evidence that <code class="highlighter-rouge">n</code> is <code class="highlighter-rouge">even</code>, then <code class="highlighter-rouge">S (S n)</code> is <code class="highlighter-rouge">even</code> as well.</li>
</ol>

<blockquote>
  <p>We can think of the definition of <code class="highlighter-rouge">even</code> as defining a Coq property <code class="highlighter-rouge">even : nat → Prop</code>, together with primitive theorems <code class="highlighter-rouge">ev_0 : even 0</code> and <code class="highlighter-rouge">ev_SS : ∀ n, even n → even (S (S n))</code>.</p>
</blockquote>

<h3 id="2-an-indexed-gadt-and-two-constructors-technically">2. An “Indexed” GADT and two constructors (Technically)</h3>

<blockquote>
  <p>In an Inductive definition, an argument to the type constructor on the left of the colon is called a “parameter”, whereas an argument on the right is called an “index”. – “Software Foundaton”</p>
</blockquote>

<p>Considered a “parametrized” ADT such as the polymorphic list,</p>

<div class="language-coq highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
</pre></td><td class="rouge-code"><pre><span class="k">Inductive</span><span class="w"> </span><span class="no">list</span><span class="w"> </span><span class="o">(</span><span class="no">X</span><span class="p">:</span><span class="kr">Type</span><span class="o">)</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="kr">Type</span><span class="w"> </span><span class="p">:=</span><span class="w">
  </span><span class="o">|</span><span class="w"> </span><span class="no">nil</span><span class="w">
  </span><span class="o">|</span><span class="w"> </span><span class="no">cons</span><span class="w"> </span><span class="o">(</span><span class="no">x</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="no">X</span><span class="o">)</span><span class="w"> </span><span class="o">(</span><span class="no">l</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="no">list</span><span class="w"> </span><span class="no">X</span><span class="o">).</span><span class="w">

</span><span class="k">Check</span><span class="w"> </span><span class="no">list</span><span class="pi">.</span><span class="w"> </span><span class="c">(* ===&gt; list : Type -&gt; Type *)</span><span class="w">
</span></pre></td></tr></tbody></table></code></pre></div></div>

<p>where we defined type con <code class="highlighter-rouge">list : Type -&gt; Type</code>, by having a type var <code class="highlighter-rouge">X</code> in the left of the <code class="highlighter-rouge">:</code>.
the <code class="highlighter-rouge">X</code> is called a <em>parameter</em> and would be <em>parametrized i.e. substituted, globally</em>, in constructors.</p>

<p>Here, we write <code class="highlighter-rouge">nat</code> in the right of the <code class="highlighter-rouge">:</code> w/o giving it a name (to refer and to substitute),
which allows the <code class="highlighter-rouge">nat</code> taking different values in different constructors (as constraints).
it’s called an <em>index</em> and will form a family of type indexed by <code class="highlighter-rouge">nat</code> (to type check?)</p>

<p>From this perspective, there is an alternative way to write this GADT:</p>

<div class="language-coq highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
</pre></td><td class="rouge-code"><pre><span class="k">Inductive</span><span class="w"> </span><span class="no">even</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="no">nat</span><span class="w"> </span><span class="err">→</span><span class="w"> </span><span class="kr">Prop</span><span class="w"> </span><span class="p">:=</span><span class="w">
</span><span class="o">|</span><span class="w"> </span><span class="no">ev_0</span><span class="w">                         </span><span class="p">:</span><span class="w"> </span><span class="no">even</span><span class="w"> </span><span class="mi">0</span><span class="w">
</span><span class="o">|</span><span class="w"> </span><span class="no">ev_SS</span><span class="w"> </span><span class="o">(</span><span class="no">n</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="no">nat</span><span class="o">)</span><span class="w"> </span><span class="o">(</span><span class="no">H</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="no">even</span><span class="w"> </span><span class="no">n</span><span class="o">)</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="no">even</span><span class="w"> </span><span class="o">(</span><span class="no">S</span><span class="w"> </span><span class="o">(</span><span class="no">S</span><span class="w"> </span><span class="no">n</span><span class="o">)).</span><span class="w">
</span></pre></td></tr></tbody></table></code></pre></div></div>

<p>we have two ways to construct the <code class="highlighter-rouge">even</code> type (<code class="highlighter-rouge">Prop &lt;: Type</code>), either or:</p>
<ol>
  <li><code class="highlighter-rouge">ev_0</code> takes no argument, so simply instantiate <code class="highlighter-rouge">even</code> with <code class="highlighter-rouge">nat</code> 0</li>
  <li><code class="highlighter-rouge">ev_SS</code> takes a <code class="highlighter-rouge">nat</code> <code class="highlighter-rouge">n</code> and a <code class="highlighter-rouge">H</code> typed <code class="highlighter-rouge">even n</code>,
    <ul>
      <li>the <em>dependency</em> between two arguments thus established!</li>
      <li>as long as the <em>constraint on same <code class="highlighter-rouge">n</code></em> is fullfilled, we can build type <code class="highlighter-rouge">even</code> with <code class="highlighter-rouge">S (S n)</code></li>
    </ul>
  </li>
</ol>

<p>The take way is that <em>dependent type (Pi-type)</em> allow us to constriant constructors with different values.</p>

<blockquote>
  <p><em>indexed</em> way is more general. it formed a larger type, and is only used when extra power needed. 
every parametrized one can be represented as indexed one (it’s just that index happended to be the same)</p>
</blockquote>

<h3 id="constructor-theorems">“Constructor Theorems”</h3>

<blockquote>
  <p>Such “constructor theorems” have the same status as proven theorems. In particular, we can use Coq’s <code class="highlighter-rouge">apply</code> tactic with the rule names to prove <code class="highlighter-rouge">even</code> for particular numbers…</p>
</blockquote>

<div class="language-coq highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
</pre></td><td class="rouge-code"><pre><span class="k">Theorem</span><span class="w"> </span><span class="no">ev_4</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="no">even</span><span class="w"> </span><span class="mi">4</span><span class="o">.</span><span class="w">
</span><span class="k">Proof</span><span class="pi">.</span><span class="w"> </span><span class="kp">apply</span><span class="w"> </span><span class="no">ev_SS</span><span class="pi">.</span><span class="w"> </span><span class="kp">apply</span><span class="w"> </span><span class="no">ev_SS</span><span class="pi">.</span><span class="w"> </span><span class="kp">apply</span><span class="w"> </span><span class="no">ev_0</span><span class="pi">.</span><span class="w"> </span><span class="k">Qed</span><span class="pi">.</span><span class="w">
</span></pre></td></tr></tbody></table></code></pre></div></div>

<p>Proof States Transition:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
</pre></td><td class="rouge-code"><pre>even 4
------ apply ev_SS.
even 2
------ apply ev_SS.
even 0
------ apply ev_0.
       Qed.
</pre></td></tr></tbody></table></code></pre></div></div>

<p>I believed what <code class="highlighter-rouge">apply</code> do is trying to <em>backward reasoning</em>, i.e. matching the goal and leave the “evidence” need to be proved (to conclude the goal).</p>

<p>we can write it as normal function application syntax w/o using tactics like other Dependent-typed PL as well</p>

<div class="language-coq highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
</pre></td><td class="rouge-code"><pre><span class="k">Theorem</span><span class="w"> </span><span class="no">ev_4'</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="no">even</span><span class="w"> </span><span class="mi">4</span><span class="o">.</span><span class="w">
</span><span class="k">Proof</span><span class="pi">.</span><span class="w"> </span><span class="kp">apply</span><span class="w"> </span><span class="o">(</span><span class="no">ev_SS</span><span class="w"> </span><span class="mi">2</span><span class="w"> </span><span class="o">(</span><span class="no">ev_SS</span><span class="w"> </span><span class="mi">0</span><span class="w"> </span><span class="no">ev_0</span><span class="o">)).</span><span class="w"> </span><span class="k">Qed</span><span class="pi">.</span><span class="w">
</span></pre></td></tr></tbody></table></code></pre></div></div>

<h2 id="using-evidence-in-proofs">Using Evidence in Proofs</h2>

<blockquote>
  <p>Besides <em>constructing evidence</em> that numbers are even, we can also <em>reason</em> about such evidence.</p>
</blockquote>

<blockquote>
  <p>Introducing <code class="highlighter-rouge">even</code> with an <code class="highlighter-rouge">Inductive</code> declaration tells Coq that these two constructors are the <strong>only</strong> ways to build evidence that numbers are <code class="highlighter-rouge">even</code>.</p>
</blockquote>

<blockquote>
  <p>In other words, if someone gives us evidence <code class="highlighter-rouge">E</code> for the assertion <code class="highlighter-rouge">even n</code>, then we know that <code class="highlighter-rouge">E</code> must have one of two shapes</p>
</blockquote>

<blockquote>
  <p>This suggests that it should be possible to analyze a hypothesis of the form <code class="highlighter-rouge">even n</code> much <em>as we do inductively defined data structures</em>; in particular, it should be possible to argue by <strong>induction</strong> and <strong>case analysis</strong> on such evidence.</p>
</blockquote>

<p>This starts to get familiar as what we did for many calculi, ranging from Logics to PLT.
This is called the <strong>Inversion property</strong>.</p>

<h3 id="inversion-on-evidence">Inversion on Evidence</h3>

<p>We can prove the inersion property by ourselves:</p>

<div class="language-coq highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
</pre></td><td class="rouge-code"><pre><span class="k">Theorem</span><span class="w"> </span><span class="no">ev_inversion</span><span class="w"> </span><span class="p">:</span><span class="w">
  </span><span class="err">∀</span><span class="o">(</span><span class="no">n</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="no">nat</span><span class="o">),</span><span class="w"> </span><span class="no">even</span><span class="w"> </span><span class="no">n</span><span class="w"> </span><span class="err">→</span><span class="w">
    </span><span class="o">(</span><span class="no">n</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="o">)</span><span class="w"> </span><span class="err">∨</span><span class="w"> </span><span class="o">(</span><span class="err">∃</span><span class="no">n'</span><span class="o">,</span><span class="w"> </span><span class="no">n</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="no">S</span><span class="w"> </span><span class="o">(</span><span class="no">S</span><span class="w"> </span><span class="no">n'</span><span class="o">)</span><span class="w"> </span><span class="err">∧</span><span class="w"> </span><span class="no">even</span><span class="w"> </span><span class="no">n'</span><span class="o">).</span><span class="w">
</span><span class="k">Proof</span><span class="pi">.</span><span class="w">
  </span><span class="kp">intros</span><span class="w"> </span><span class="no">n</span><span class="w"> </span><span class="no">E</span><span class="pi">.</span><span class="w">
  </span><span class="kp">destruct</span><span class="w"> </span><span class="no">E</span><span class="w"> </span><span class="kr">as</span><span class="w"> </span><span class="o">[</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="no">n'</span><span class="w"> </span><span class="no">E'</span><span class="o">].</span><span class="w">
  </span><span class="o">-</span><span class="w"> </span><span class="c">(* E = ev_0 : even 0 *)</span><span class="w">                  </span><span class="no">left</span><span class="pi">.</span><span class="w"> </span><span class="ne">reflexivity</span><span class="pi">.</span><span class="w">
  </span><span class="o">-</span><span class="w"> </span><span class="c">(* E = ev_SS n', E' : even (S (S n')) *)</span><span class="w"> </span><span class="no">right</span><span class="pi">.</span><span class="w"> </span><span class="err">∃</span><span class="no">n'</span><span class="pi">.</span><span class="w"> </span><span class="kp">split</span><span class="pi">.</span><span class="w"> </span><span class="ne">reflexivity</span><span class="pi">.</span><span class="w"> </span><span class="kp">apply</span><span class="w"> </span><span class="no">E'</span><span class="pi">.</span><span class="w">
</span><span class="k">Qed</span><span class="pi">.</span><span class="w">
</span></pre></td></tr></tbody></table></code></pre></div></div>

<p>But Coq provide the <code class="highlighter-rouge">inversion</code> tactics that does more! (not always good tho, too automagical)</p>

<blockquote>
  <p>The inversion tactic does quite a bit of work. When applied to equalities, as a special case, it does the work of both <code class="highlighter-rouge">discriminate</code> and <code class="highlighter-rouge">injection</code>. In addition, it carries out the <code class="highlighter-rouge">intros</code> and <code class="highlighter-rouge">rewrite</code>s</p>
</blockquote>

<blockquote>
  <p>Here’s how inversion works in general. Suppose the name <code class="highlighter-rouge">H</code> refers to an assumption <code class="highlighter-rouge">P</code> in the current context, <em>where <code class="highlighter-rouge">P</code> has been defined by an <code class="highlighter-rouge">Inductive</code> declaration</em>. Then, for each of the constructors of <code class="highlighter-rouge">P</code>, <code class="highlighter-rouge">inversion H</code> generates a subgoal in which <code class="highlighter-rouge">H</code> has been replaced by the <em>exact, specific conditions under which this constructor could have been used to prove <code class="highlighter-rouge">P</code></em>. 
Some of these subgoals will be self-contradictory; inversion throws these away. The ones that are left represent the cases that must be proved to establish the original goal. For those, inversion adds all equations into the proof context that must hold of the arguments given to <code class="highlighter-rouge">P</code> (e.g., <code class="highlighter-rouge">S (S n') = n</code> in the proof of <code class="highlighter-rouge">evSS_ev</code>).
(<code class="highlighter-rouge">9-proof-object.md</code> has a better explaination on <code class="highlighter-rouge">inversion</code>)</p>
</blockquote>

<p><code class="highlighter-rouge">inversion</code> is a specific use upon <code class="highlighter-rouge">destruct</code> (both do case analysis on constructors), but many property need <code class="highlighter-rouge">induction</code>!. 
By <code class="highlighter-rouge">induction (even n)</code>, we have cases and subgoals splitted, and induction hypothesis as well.</p>

<h3 id="induction-on-evidence">Induction on Evidence</h3>

<p>Similar to induction on inductively defined data such as <code class="highlighter-rouge">list</code>:</p>
<blockquote>
  <p>To prove a property of (for any <code class="highlighter-rouge">X</code>)                       <code class="highlighter-rouge">list X</code> holds, we can use <code class="highlighter-rouge">induction</code> on <code class="highlighter-rouge">list X</code>.
To prove a property of <code class="highlighter-rouge">n</code> holds for all numbers for which <code class="highlighter-rouge">even n</code> holds, we can use <code class="highlighter-rouge">induction</code> on <code class="highlighter-rouge">even n</code>.</p>
</blockquote>

<h4 id="notes-on-induction">Notes on induction</h4>

<p><em>The principle of induction</em> is to prove <code class="highlighter-rouge">P(n-1) -&gt; P(n)</code> (多米诺) for some (well-founded partial order) set of <code class="highlighter-rouge">n</code>.</p>

<p>Here, we are induction over “the set of numbers fullfilling the property <code class="highlighter-rouge">even</code>”. 
Noticed that we r proving things over this set, meaning we already have it (i.e. a proof, or a evidence) in premises, instead of proving the <code class="highlighter-rouge">even</code>ness of the set.</p>

<h4 id="proof-by-mathematical-induction-is-deductive-reasoning">Proof by Mathematical Induction is Deductive Reasoning</h4>

<blockquote>
  <p>“Proof by induction,” despite the name, is deductive. The reason is that proof by induction does not simply involve “going from many specific cases to the general case.” Instead, in order for proof by induction to work, we need a deductive proof that each specific case implies the next specific case. Mathematical induction is not philosophical induction.</p>
</blockquote>
<p><a href="https://math.stackexchange.com/a/1960895/528269">https://math.stackexchange.com/a/1960895/528269</a></p>

<blockquote>
  <p>Mathematical induction is an inference rule used in formal proofs. Proofs by mathematical induction are, in fact, examples of deductive reasoning.
Equivalence with the well-ordering principle: The principle of mathematical induction is usually stated as an axiom of the natural numbers; see Peano axioms. However, it can be proved from the well-ordering principle. Indeed, suppose the following:</p>
</blockquote>
<p><a href="https://en.wikipedia.org/wiki/Mathematical_induction">https://en.wikipedia.org/wiki/Mathematical_induction</a></p>

<h4 id="also-structual-induction-is-one-kind-of-math-induction">Also, Structual Induction is one kind of Math. Induction</h4>

<blockquote>
  <p>和标准的数学归纳法等价于良序原理一样，结构归纳法也等价于良序原理。</p>
</blockquote>

<blockquote>
  <p>…A <em>well-founded</em> <em>partial order</em> is defined on the structures…
…Formally speaking, this then satisfies the premises of an <em>axiom of well-founded induction</em>…</p>
</blockquote>
<p><a href="https://en.wikipedia.org/wiki/Structural_induction">https://en.wikipedia.org/wiki/Structural_induction</a></p>

<p>In terms of Well-ordering and Well-founded:</p>

<blockquote>
  <p>If the set of all structures of a certain kind admits a well-founded partial order, 
then every nonempty subset must have a minimal element. (This is the definition of “well-founded”.)
如果某种整个结构的集容纳一个良基偏序， 那么每个非空子集一定都含有最小元素。（其实这也是良基的定义</p>
</blockquote>

<h2 id="inductive-relations">Inductive Relations</h2>

<p>Just as a single-argument proposition defines a <em>property</em>, 性质
a two-argument proposition defines a <em>relation</em>. 关系</p>

<div class="language-coq highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
</pre></td><td class="rouge-code"><pre><span class="k">Inductive</span><span class="w"> </span><span class="no">le</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="no">nat</span><span class="w"> </span><span class="err">→</span><span class="w"> </span><span class="no">nat</span><span class="w"> </span><span class="err">→</span><span class="w"> </span><span class="kr">Prop</span><span class="w"> </span><span class="p">:=</span><span class="w">
  </span><span class="o">|</span><span class="w"> </span><span class="no">le_n</span><span class="w"> </span><span class="no">n</span><span class="w">                </span><span class="p">:</span><span class="w"> </span><span class="no">le</span><span class="w"> </span><span class="no">n</span><span class="w"> </span><span class="no">n</span><span class="w">
  </span><span class="o">|</span><span class="w"> </span><span class="no">le_S</span><span class="w"> </span><span class="no">n</span><span class="w"> </span><span class="no">m</span><span class="w"> </span><span class="o">(</span><span class="no">H</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="no">le</span><span class="w"> </span><span class="no">n</span><span class="w"> </span><span class="no">m</span><span class="o">)</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="no">le</span><span class="w"> </span><span class="no">n</span><span class="w"> </span><span class="o">(</span><span class="no">S</span><span class="w"> </span><span class="no">m</span><span class="o">).</span><span class="w">

</span><span class="k">Notation</span><span class="w"> </span><span class="s2">"n ≤ m"</span><span class="w"> </span><span class="p">:=</span><span class="w"> </span><span class="o">(</span><span class="no">le</span><span class="w"> </span><span class="no">n</span><span class="w"> </span><span class="no">m</span><span class="o">).</span><span class="w">
</span></pre></td></tr></tbody></table></code></pre></div></div>

<blockquote>
  <p>It says that there are two ways to <em>give evidence</em> that one number is less than or equal to another:</p>
</blockquote>

<ol>
  <li>either same number</li>
  <li>or give evidence that <code class="highlighter-rouge">n ≤ m</code> then we can have <code class="highlighter-rouge">n ≤ m + 1</code>.</li>
</ol>

<p>and we can use the same tactics as we did for properties.</p>

<h2 id="slide-qa---1">Slide Q&amp;A - 1</h2>

<ol>
  <li>First <code class="highlighter-rouge">destruct</code> <code class="highlighter-rouge">even n</code> into 2 cases, then <code class="highlighter-rouge">discriminate</code> on each.</li>
</ol>

<p>Another way… 
rewriting <code class="highlighter-rouge">n=1</code> on <code class="highlighter-rouge">even n</code>. It won’t compute <code class="highlighter-rouge">Prop</code>, but <code class="highlighter-rouge">destruct</code> can do some <code class="highlighter-rouge">discriminate</code> behind the scene.</p>

<h2 id="slide-qa---2">Slide Q&amp;A - 2</h2>

<p><code class="highlighter-rouge">inversion</code> and <code class="highlighter-rouge">rewrite plus_comm</code> (for <code class="highlighter-rouge">n+2</code>)</p>

<h2 id="destruct-vs-inversion-vs-induction"><code class="highlighter-rouge">destruct</code> vs. <code class="highlighter-rouge">inversion</code> vs. <code class="highlighter-rouge">induction</code>.</h2>

<blockquote>
  <p><code class="highlighter-rouge">destruct</code>, <code class="highlighter-rouge">inversion</code>, <code class="highlighter-rouge">induction</code> (on general thing)… similar/specialized version of each…</p>
</blockquote>

<p>Trying to internalize this concept better: <em>When to use which?</em></p>

<p>For any inductively defined proposition (<code class="highlighter-rouge">&lt;: Type</code>) in hypothesis:
meaning from type perspective, it’s already a “proper type” (<code class="highlighter-rouge">::*</code>)</p>

<div class="language-coq highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre></td><td class="rouge-code"><pre><span class="k">Inductive</span><span class="w"> </span><span class="no">P</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="no">C1</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="no">P1</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="no">C2</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="no">A2</span><span class="w"> </span><span class="p">-&gt;</span><span class="w"> </span><span class="no">P2</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="o">...</span><span class="w">
</span></pre></td></tr></tbody></table></code></pre></div></div>

<ol>
  <li><code class="highlighter-rouge">destruct</code>     case analysis on inductive type</li>
</ol>

<ul>
  <li>simply give you each cases, i.e. each constructors.</li>
  <li>we can destruct on <code class="highlighter-rouge">a =? b</code> since <code class="highlighter-rouge">=?</code> is inductively defined.</li>
</ul>

<ol>
  <li><code class="highlighter-rouge">induction</code>    use induction principle</li>
</ol>

<ul>
  <li>proving <code class="highlighter-rouge">P</code> holds for all base cases</li>
  <li>proving <code class="highlighter-rouge">P(n)</code> holds w/ <code class="highlighter-rouge">P(n-1)</code> for all inductive cases
(<code class="highlighter-rouge">destruct</code> stucks in this case because of no induction hypothesis gained from induction principle)</li>
</ul>

<ol>
  <li><code class="highlighter-rouge">inversion</code>    invert the conclusion and give you all cases with premises of that case.</li>
</ol>

<p>For GADT, i.e. “indexed” <code class="highlighter-rouge">Prop</code> (property/relation), <code class="highlighter-rouge">P</code> could have many shape
<code class="highlighter-rouge">inversion</code> give you <code class="highlighter-rouge">Ax</code> for shape <code class="highlighter-rouge">P</code> assuming built with <code class="highlighter-rouge">Cx</code></p>

<p><code class="highlighter-rouge">inversion</code> discards cases when shape <code class="highlighter-rouge">P != Px</code>.
(<code class="highlighter-rouge">destruct</code> stucks in this case because of no equation gained from inversion lemma)</p>

<h2 id="case-study-regular-expressions">Case Study: Regular Expressions</h2>

<h3 id="definition">Definition</h3>

<p><em>Definition of RegExp in formal language can be found in FCT/CC materials</em></p>

<div class="language-coq highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
</pre></td><td class="rouge-code"><pre><span class="k">Inductive</span><span class="w"> </span><span class="no">reg_exp</span><span class="w"> </span><span class="o">{</span><span class="no">T</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="kr">Type</span><span class="o">}</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="kr">Type</span><span class="w"> </span><span class="p">:=</span><span class="w">
  </span><span class="o">|</span><span class="w"> </span><span class="no">EmptySet</span><span class="w">                 </span><span class="c">(* ∅ *)</span><span class="w">
  </span><span class="o">|</span><span class="w"> </span><span class="no">EmptyStr</span><span class="w">                 </span><span class="c">(* ε *)</span><span class="w">
  </span><span class="o">|</span><span class="w"> </span><span class="no">Char</span><span class="w"> </span><span class="o">(</span><span class="no">t</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="no">T</span><span class="o">)</span><span class="w">
  </span><span class="o">|</span><span class="w"> </span><span class="no">App</span><span class="w"> </span><span class="o">(</span><span class="no">r1</span><span class="w"> </span><span class="no">r2</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="no">reg_exp</span><span class="o">)</span><span class="w">    </span><span class="c">(* r1r2 *)</span><span class="w">
  </span><span class="o">|</span><span class="w"> </span><span class="no">Union</span><span class="w"> </span><span class="o">(</span><span class="no">r1</span><span class="w"> </span><span class="no">r2</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="no">reg_exp</span><span class="o">)</span><span class="w">  </span><span class="c">(* r1 | r2 *)</span><span class="w">
  </span><span class="o">|</span><span class="w"> </span><span class="no">Star</span><span class="w"> </span><span class="o">(</span><span class="no">r</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="no">reg_exp</span><span class="o">).</span><span class="w">      </span><span class="c">(* r*  *)</span><span class="w">
</span></pre></td></tr></tbody></table></code></pre></div></div>

<blockquote>
  <p>Note that this definition is <em>polymorphic</em>. 
We depart slightly in that <em>we do not require the type <code class="highlighter-rouge">T</code> to be finite</em>. (difference not significant here)</p>
</blockquote>

<blockquote>
  <p><code class="highlighter-rouge">reg_exp T</code> describe <em>strings</em> with characters drawn from <code class="highlighter-rouge">T</code> — that is, <strong>lists of elements of <code class="highlighter-rouge">T</code></strong>.</p>
</blockquote>

<h3 id="matching">Matching</h3>

<p>The matching is somewhat similar to <em>Parser Combinator</em> in Haskell…</p>

<p>e.g.
<code class="highlighter-rouge">EmptyStr</code> matches <code class="highlighter-rouge">[]</code>
<code class="highlighter-rouge">Char x</code>   matches <code class="highlighter-rouge">[x]</code></p>

<blockquote>
  <p>we definied it into an <code class="highlighter-rouge">Inductive</code> relation (can be displayed as <em>inference-rule</em>). 
somewhat type-level computing !</p>
</blockquote>

<div class="language-coq highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
</pre></td><td class="rouge-code"><pre><span class="k">Inductive</span><span class="w"> </span><span class="no">exp_match</span><span class="w"> </span><span class="o">{</span><span class="no">T</span><span class="o">}</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="no">list</span><span class="w"> </span><span class="no">T</span><span class="w"> </span><span class="err">→</span><span class="w"> </span><span class="no">reg_exp</span><span class="w"> </span><span class="err">→</span><span class="w"> </span><span class="kr">Prop</span><span class="w"> </span><span class="p">:=</span><span class="w">
</span><span class="o">|</span><span class="w"> </span><span class="no">MEmpty</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="no">exp_match</span><span class="w"> </span><span class="o">[]</span><span class="w"> </span><span class="no">EmptyStr</span><span class="w">
</span><span class="o">|</span><span class="w"> </span><span class="no">MChar</span><span class="w"> </span><span class="no">x</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="no">exp_match</span><span class="w"> </span><span class="o">[</span><span class="no">x</span><span class="o">]</span><span class="w"> </span><span class="o">(</span><span class="no">Char</span><span class="w"> </span><span class="no">x</span><span class="o">)</span><span class="w">
</span><span class="o">|</span><span class="w"> </span><span class="no">MApp</span><span class="w"> </span><span class="no">s1</span><span class="w"> </span><span class="no">re1</span><span class="w"> </span><span class="no">s2</span><span class="w"> </span><span class="no">re2</span><span class="w">
            </span><span class="o">(</span><span class="no">H1</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="no">exp_match</span><span class="w"> </span><span class="no">s1</span><span class="w"> </span><span class="no">re1</span><span class="o">)</span><span class="w">
            </span><span class="o">(</span><span class="no">H2</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="no">exp_match</span><span class="w"> </span><span class="no">s2</span><span class="w"> </span><span class="no">re2</span><span class="o">)</span><span class="w"> </span><span class="p">:</span><span class="w">
            </span><span class="no">exp_match</span><span class="w"> </span><span class="o">(</span><span class="no">s1</span><span class="w"> </span><span class="o">++</span><span class="w"> </span><span class="no">s2</span><span class="o">)</span><span class="w"> </span><span class="o">(</span><span class="no">App</span><span class="w"> </span><span class="no">re1</span><span class="w"> </span><span class="no">re2</span><span class="o">)</span><span class="w">
</span><span class="c">(** etc. **)</span><span class="w">

</span><span class="k">Notation</span><span class="w"> </span><span class="s2">"s =~ re"</span><span class="w"> </span><span class="p">:=</span><span class="w"> </span><span class="o">(</span><span class="no">exp_match</span><span class="w"> </span><span class="no">s</span><span class="w"> </span><span class="no">re</span><span class="o">)</span><span class="w"> </span><span class="o">(</span><span class="kp">at</span><span class="w"> </span><span class="no">level</span><span class="w"> </span><span class="mi">80</span><span class="o">).</span><span class="w">  </span><span class="c">(* the Perl notation! *)</span><span class="w">
</span></pre></td></tr></tbody></table></code></pre></div></div>

<h2 id="slide-qa---3">Slide Q&amp;A - 3</h2>

<p>The lack of rule for <code class="highlighter-rouge">EmptySet</code> (“negative rule”) give us what we want as PLT</p>

<h3 id="union-and-star"><code class="highlighter-rouge">Union</code> and <code class="highlighter-rouge">Star</code>.</h3>

<blockquote>
  <p>the informal rules for <code class="highlighter-rouge">Union</code> and <code class="highlighter-rouge">Star</code> correspond to <em>two constructors</em> each.</p>
</blockquote>

<div class="language-coq highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
</pre></td><td class="rouge-code"><pre><span class="o">|</span><span class="w"> </span><span class="no">MUnionL</span><span class="w"> </span><span class="no">s1</span><span class="w"> </span><span class="no">re1</span><span class="w"> </span><span class="no">re2</span><span class="w">
              </span><span class="o">(</span><span class="no">H1</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="no">exp_match</span><span class="w"> </span><span class="no">s1</span><span class="w"> </span><span class="no">re1</span><span class="o">)</span><span class="w"> </span><span class="p">:</span><span class="w">
              </span><span class="no">exp_match</span><span class="w"> </span><span class="no">s1</span><span class="w"> </span><span class="o">(</span><span class="no">Union</span><span class="w"> </span><span class="no">re1</span><span class="w"> </span><span class="no">re2</span><span class="o">)</span><span class="w">
</span><span class="o">|</span><span class="w"> </span><span class="no">MUnionR</span><span class="w"> </span><span class="no">re1</span><span class="w"> </span><span class="no">s2</span><span class="w"> </span><span class="no">re2</span><span class="w">
              </span><span class="o">(</span><span class="no">H2</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="no">exp_match</span><span class="w"> </span><span class="no">s2</span><span class="w"> </span><span class="no">re2</span><span class="o">)</span><span class="w"> </span><span class="p">:</span><span class="w">
              </span><span class="no">exp_match</span><span class="w"> </span><span class="no">s2</span><span class="w"> </span><span class="o">(</span><span class="no">Union</span><span class="w"> </span><span class="no">re1</span><span class="w"> </span><span class="no">re2</span><span class="o">)</span><span class="w">
</span><span class="o">|</span><span class="w"> </span><span class="no">MStar0</span><span class="w"> </span><span class="no">re</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="no">exp_match</span><span class="w"> </span><span class="o">[]</span><span class="w"> </span><span class="o">(</span><span class="no">Star</span><span class="w"> </span><span class="no">re</span><span class="o">)</span><span class="w">
</span><span class="o">|</span><span class="w"> </span><span class="no">MStarApp</span><span class="w"> </span><span class="no">s1</span><span class="w"> </span><span class="no">s2</span><span class="w"> </span><span class="no">re</span><span class="w">
              </span><span class="o">(</span><span class="no">H1</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="no">exp_match</span><span class="w"> </span><span class="no">s1</span><span class="w"> </span><span class="no">re</span><span class="o">)</span><span class="w">
              </span><span class="o">(</span><span class="no">H2</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="no">exp_match</span><span class="w"> </span><span class="no">s2</span><span class="w"> </span><span class="o">(</span><span class="no">Star</span><span class="w"> </span><span class="no">re</span><span class="o">))</span><span class="w"> </span><span class="p">:</span><span class="w">
              </span><span class="no">exp_match</span><span class="w"> </span><span class="o">(</span><span class="no">s1</span><span class="w"> </span><span class="o">++</span><span class="w"> </span><span class="no">s2</span><span class="o">)</span><span class="w"> </span><span class="o">(</span><span class="no">Star</span><span class="w"> </span><span class="no">re</span><span class="o">).</span><span class="w">
</span></pre></td></tr></tbody></table></code></pre></div></div>

<p>Thinking about their <em>NFA</em>: they both have non-deterministic branches!
The recursive occurrences of <code class="highlighter-rouge">exp_match</code> gives as <em>direct argument</em> (evidence) about which branches we goes.</p>

<blockquote>
  <p>we need some <em>sanity check</em> since Coq simply trust what we declared…
that’s why there is even Quick Check for Coq.</p>
</blockquote>

<h3 id="direct-proof">Direct Proof</h3>

<p>In fact, <code class="highlighter-rouge">MApp</code> is also non-deterministic about how does <code class="highlighter-rouge">re1</code> and <code class="highlighter-rouge">re2</code> collaborate…
So we have to be explicit:</p>

<div class="language-coq highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
</pre></td><td class="rouge-code"><pre><span class="k">Example</span><span class="w"> </span><span class="no">reg_exp_ex2</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="o">[</span><span class="mi">1</span><span class="p">;</span><span class="w"> </span><span class="mi">2</span><span class="o">]</span><span class="w"> </span><span class="o">=~</span><span class="w"> </span><span class="no">App</span><span class="w"> </span><span class="o">(</span><span class="no">Char</span><span class="w"> </span><span class="mi">1</span><span class="o">)</span><span class="w"> </span><span class="o">(</span><span class="no">Char</span><span class="w"> </span><span class="mi">2</span><span class="o">).</span><span class="w">
</span><span class="k">Proof</span><span class="pi">.</span><span class="w">
  </span><span class="kp">apply</span><span class="w"> </span><span class="o">(</span><span class="no">MApp</span><span class="w"> </span><span class="o">[</span><span class="mi">1</span><span class="o">]</span><span class="w"> </span><span class="p">_</span><span class="w"> </span><span class="o">[</span><span class="mi">2</span><span class="o">]).</span><span class="w">
  </span><span class="o">...</span><span class="w">
</span></pre></td></tr></tbody></table></code></pre></div></div>

<h3 id="inversion-on-evidence-1">Inversion on Evidence</h3>

<p>This, if we want to prove via <code class="highlighter-rouge">destruct</code>, 
we have to write our own <em>inversion lemma</em> (like <code class="highlighter-rouge">ev_inversion</code> for <code class="highlighter-rouge">even</code>).
Otherwise we have no equation (which we should have) to say <code class="highlighter-rouge">contradiction</code>.</p>

<div class="language-coq highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
</pre></td><td class="rouge-code"><pre><span class="k">Example</span><span class="w"> </span><span class="no">reg_exp_ex3</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="o">~</span><span class="w"> </span><span class="o">([</span><span class="mi">1</span><span class="p">;</span><span class="w"> </span><span class="mi">2</span><span class="o">]</span><span class="w"> </span><span class="o">=~</span><span class="w"> </span><span class="no">Char</span><span class="w"> </span><span class="mi">1</span><span class="o">).</span><span class="w">
</span><span class="k">Proof</span><span class="pi">.</span><span class="w">
  </span><span class="kp">intros</span><span class="w"> </span><span class="no">H</span><span class="pi">.</span><span class="w"> </span><span class="kp">inversion</span><span class="w"> </span><span class="no">H</span><span class="pi">.</span><span class="w">
</span><span class="k">Qed</span><span class="pi">.</span><span class="w">
</span></pre></td></tr></tbody></table></code></pre></div></div>

<h3 id="manual-manipulation">Manual Manipulation</h3>

<div class="language-coq highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
</pre></td><td class="rouge-code"><pre><span class="k">Lemma</span><span class="w"> </span><span class="no">MStar1</span><span class="w"> </span><span class="p">:</span><span class="w">
  </span><span class="kr">forall</span><span class="w"> </span><span class="no">T</span><span class="w"> </span><span class="no">s</span><span class="w"> </span><span class="o">(</span><span class="no">re</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="o">@</span><span class="no">reg_exp</span><span class="w"> </span><span class="no">T</span><span class="o">)</span><span class="w"> </span><span class="o">,</span><span class="w">
    </span><span class="no">s</span><span class="w"> </span><span class="o">=~</span><span class="w"> </span><span class="no">re</span><span class="w"> </span><span class="p">-&gt;</span><span class="w">
    </span><span class="no">s</span><span class="w"> </span><span class="o">=~</span><span class="w"> </span><span class="no">Star</span><span class="w"> </span><span class="no">re</span><span class="pi">.</span><span class="w">
</span><span class="k">Proof</span><span class="pi">.</span><span class="w">
  </span><span class="kp">intros</span><span class="w"> </span><span class="no">T</span><span class="w"> </span><span class="no">s</span><span class="w"> </span><span class="no">re</span><span class="w"> </span><span class="no">H</span><span class="pi">.</span><span class="w">
  </span><span class="kp">rewrite</span><span class="w"> </span><span class="o">&lt;-</span><span class="w"> </span><span class="o">(</span><span class="no">app_nil_r</span><span class="w"> </span><span class="p">_</span><span class="w"> </span><span class="no">s</span><span class="o">).</span><span class="w">  </span><span class="c">(* extra "massaging" to convert [s] =&gt; [s ++ []] *)</span><span class="w">
  </span><span class="kp">apply</span><span class="w"> </span><span class="o">(</span><span class="no">MStarApp</span><span class="w"> </span><span class="no">s</span><span class="w"> </span><span class="o">[]</span><span class="w"> </span><span class="no">re</span><span class="o">).</span><span class="w">    </span><span class="c">(* to the shape [MStarApp] expected thus can pattern match on *)</span><span class="w">

      </span><span class="c">(* proving [MStarApp] requires [s1 s2 re H1 H2]. By giving [s [] re], we left two evidence *)</span><span class="w">
      </span><span class="o">|</span><span class="w"> </span><span class="no">MStarApp</span><span class="w"> </span><span class="no">s1</span><span class="w"> </span><span class="no">s2</span><span class="w"> </span><span class="no">re</span><span class="w">
          </span><span class="o">(</span><span class="no">H1</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="no">exp_match</span><span class="w"> </span><span class="no">s1</span><span class="w"> </span><span class="no">re</span><span class="o">)</span><span class="w">
          </span><span class="o">(</span><span class="no">H2</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="no">exp_match</span><span class="w"> </span><span class="no">s2</span><span class="w"> </span><span class="o">(</span><span class="no">Star</span><span class="w"> </span><span class="no">re</span><span class="o">))</span><span class="w"> </span><span class="p">:</span><span class="w">
          </span><span class="no">exp_match</span><span class="w"> </span><span class="o">(</span><span class="no">s1</span><span class="w"> </span><span class="o">++</span><span class="w"> </span><span class="no">s2</span><span class="o">)</span><span class="w"> </span><span class="o">(</span><span class="no">Star</span><span class="w"> </span><span class="no">re</span><span class="o">).</span><span class="w">

  </span><span class="o">-</span><span class="w"> </span><span class="kp">apply</span><span class="w"> </span><span class="no">H</span><span class="pi">.</span><span class="w">                   </span><span class="c">(* evidence H1 *)</span><span class="w">
  </span><span class="o">-</span><span class="w"> </span><span class="kp">apply</span><span class="w"> </span><span class="no">MStar0</span><span class="pi">.</span><span class="w">              </span><span class="c">(* evidence H2 *)</span><span class="w">
</span><span class="k">Qed</span><span class="pi">.</span><span class="w">                           </span><span class="c">(* the fun fact is that we can really think the _proof_
                                  as providing evidence by _partial application_. *)</span><span class="w">
</span></pre></td></tr></tbody></table></code></pre></div></div>

<h3 id="induction-on-evidence-1">Induction on Evidence</h3>

<blockquote>
  <p>By the recursive nature of <code class="highlighter-rouge">exp_match</code>, proofs will often require induction.</p>
</blockquote>

<div class="language-coq highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
</pre></td><td class="rouge-code"><pre><span class="c">(** Recursively collecting all characters that occur in a regex **)</span><span class="w">
</span><span class="k">Fixpoint</span><span class="w"> </span><span class="no">re_chars</span><span class="w"> </span><span class="o">{</span><span class="no">T</span><span class="o">}</span><span class="w"> </span><span class="o">(</span><span class="no">re</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="no">reg_exp</span><span class="o">)</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="no">list</span><span class="w"> </span><span class="no">T</span><span class="w"> </span><span class="p">:=</span><span class="w">
  </span><span class="kr">match</span><span class="w"> </span><span class="no">re</span><span class="w"> </span><span class="kp">with</span><span class="w">
  </span><span class="o">|</span><span class="w"> </span><span class="no">EmptySet</span><span class="w"> </span><span class="err">⇒</span><span class="w"> </span><span class="o">[]</span><span class="w">
  </span><span class="o">|</span><span class="w"> </span><span class="no">EmptyStr</span><span class="w"> </span><span class="err">⇒</span><span class="w"> </span><span class="o">[]</span><span class="w">
  </span><span class="o">|</span><span class="w"> </span><span class="no">Char</span><span class="w"> </span><span class="no">x</span><span class="w"> </span><span class="err">⇒</span><span class="w"> </span><span class="o">[</span><span class="no">x</span><span class="o">]</span><span class="w">
  </span><span class="o">|</span><span class="w"> </span><span class="no">App</span><span class="w"> </span><span class="no">re1</span><span class="w"> </span><span class="no">re2</span><span class="w"> </span><span class="err">⇒</span><span class="w"> </span><span class="no">re_chars</span><span class="w"> </span><span class="no">re1</span><span class="w"> </span><span class="o">++</span><span class="w"> </span><span class="no">re_chars</span><span class="w"> </span><span class="no">re2</span><span class="w">
  </span><span class="o">|</span><span class="w"> </span><span class="no">Union</span><span class="w"> </span><span class="no">re1</span><span class="w"> </span><span class="no">re2</span><span class="w"> </span><span class="err">⇒</span><span class="w"> </span><span class="no">re_chars</span><span class="w"> </span><span class="no">re1</span><span class="w"> </span><span class="o">++</span><span class="w"> </span><span class="no">re_chars</span><span class="w"> </span><span class="no">re2</span><span class="w">
  </span><span class="o">|</span><span class="w"> </span><span class="no">Star</span><span class="w"> </span><span class="no">re</span><span class="w"> </span><span class="err">⇒</span><span class="w"> </span><span class="no">re_chars</span><span class="w"> </span><span class="no">re</span><span class="w">
  </span><span class="kr">end</span><span class="pi">.</span><span class="w">
</span></pre></td></tr></tbody></table></code></pre></div></div>

<p>The proof of <code class="highlighter-rouge">in_re_match</code> went through by <code class="highlighter-rouge">inversion</code> on relation <code class="highlighter-rouge">s =~ re</code>. (which gives us all 7 cases.)
The interesting case is <code class="highlighter-rouge">MStarApp</code>, where the proof tree has two <em>branches</em> (of premises):</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
</pre></td><td class="rouge-code"><pre>                  s1 =~ re    s2 =~ Star re
                 ---------------------------            (MStarApp)
                    s1 ++ s2 =~ Star re
</pre></td></tr></tbody></table></code></pre></div></div>

<p>So by induction on the relation (rule), we got <em>two induction hypotheses</em>!
That’s what we need for the proof.</p>

<h2 id="the-remember-tactic-induction-on-evidence-of-a-specific-case">The <code class="highlighter-rouge">remember</code> tactic (Induction on Evidence of A Specific Case)</h2>

<p>One interesting/confusing features is that <code class="highlighter-rouge">induction</code> over a term that’s <em>insuffciently general</em>. e.g.</p>

<div class="language-coq highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
</pre></td><td class="rouge-code"><pre><span class="k">Lemma</span><span class="w"> </span><span class="no">star_app</span><span class="p">:</span><span class="w"> </span><span class="err">∀</span><span class="no">T</span><span class="w"> </span><span class="o">(</span><span class="no">s1</span><span class="w"> </span><span class="no">s2</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="no">list</span><span class="w"> </span><span class="no">T</span><span class="o">)</span><span class="w"> </span><span class="o">(</span><span class="no">re</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="o">@</span><span class="no">reg_exp</span><span class="w"> </span><span class="no">T</span><span class="o">),</span><span class="w">
  </span><span class="no">s1</span><span class="w"> </span><span class="o">=~</span><span class="w"> </span><span class="no">Star</span><span class="w"> </span><span class="no">re</span><span class="w"> </span><span class="err">→</span><span class="w">
  </span><span class="no">s2</span><span class="w"> </span><span class="o">=~</span><span class="w"> </span><span class="no">Star</span><span class="w"> </span><span class="no">re</span><span class="w"> </span><span class="err">→</span><span class="w">
  </span><span class="no">s1</span><span class="w"> </span><span class="o">++</span><span class="w"> </span><span class="no">s2</span><span class="w"> </span><span class="o">=~</span><span class="w"> </span><span class="no">Star</span><span class="w"> </span><span class="no">re</span><span class="pi">.</span><span class="w">
</span><span class="k">Proof</span><span class="pi">.</span><span class="w">
  </span><span class="kp">intros</span><span class="w"> </span><span class="no">T</span><span class="w"> </span><span class="no">s1</span><span class="w"> </span><span class="no">s2</span><span class="w"> </span><span class="no">re</span><span class="w"> </span><span class="no">H1</span><span class="pi">.</span><span class="w">
</span></pre></td></tr></tbody></table></code></pre></div></div>

<p>Here, we know the fact that both <code class="highlighter-rouge">s1</code> and <code class="highlighter-rouge">s2</code> are matching with the form <code class="highlighter-rouge">Star re</code>. 
But by <code class="highlighter-rouge">induction</code>. it will give us <em>all 7 cases</em> to prove, but <em>5 of them are contradictory</em>!</p>

<p>That’s where we need <code class="highlighter-rouge">remember (Star re) as re'</code> to get this bit of information back to <code class="highlighter-rouge">discriminate</code>.</p>

<h3 id="sidenotes-inversion-vs-induction-on-evidence">Sidenotes: <code class="highlighter-rouge">inversion</code> vs. <code class="highlighter-rouge">induction</code> on evidence</h3>

<p>We might attemp to use <code class="highlighter-rouge">inversion</code>,
which is best suitted for have a specific conclusion of some rule and inverts back to get its premises.</p>

<p>But for <em>recursive cases</em> (e.g. <code class="highlighter-rouge">Star</code>), we always need <code class="highlighter-rouge">induction</code>.</p>

<p><code class="highlighter-rouge">induction</code> on a specific conclusion then <code class="highlighter-rouge">remember + contradiction</code> is similar with how <code class="highlighter-rouge">inversion</code> solves contradictionary cases. (They both <code class="highlighter-rouge">destruct</code> the inductively defined things for sure)</p>

<h2 id="exercise-5-stars-advanced-pumping">Exercise: 5 stars, advanced (pumping)</h2>

<p>FCT/Wikipedia “proves” <a href="https://en.wikipedia.org/wiki/Pumping_lemma_for_regular_languages">pumping lemma for regex</a> in a non-constructive way.</p>

<p>Here we attempts to give a constructive proof.</p>

<h2 id="case-study-improving-reflection-互映">Case Study: Improving Reflection (互映)</h2>

<blockquote>
  <p>we often need to relate boolean computations to statements in <code class="highlighter-rouge">Prop</code></p>
</blockquote>

<div class="language-coq highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
</pre></td><td class="rouge-code"><pre><span class="k">Inductive</span><span class="w"> </span><span class="no">reflect</span><span class="w"> </span><span class="o">(</span><span class="no">P</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="kr">Prop</span><span class="o">)</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="no">bool</span><span class="w"> </span><span class="err">→</span><span class="w"> </span><span class="kr">Prop</span><span class="w"> </span><span class="p">:=</span><span class="w">
</span><span class="o">|</span><span class="w"> </span><span class="no">ReflectT</span><span class="w"> </span><span class="o">(</span><span class="no">H</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="no">P</span><span class="o">)</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="no">reflect</span><span class="w"> </span><span class="no">P</span><span class="w"> </span><span class="no">true</span><span class="w">
</span><span class="o">|</span><span class="w"> </span><span class="no">ReflectF</span><span class="w"> </span><span class="o">(</span><span class="no">H</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="err">¬</span><span class="no">P</span><span class="o">)</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="no">reflect</span><span class="w"> </span><span class="no">P</span><span class="w"> </span><span class="no">false</span><span class="pi">.</span><span class="w">
</span></pre></td></tr></tbody></table></code></pre></div></div>

<p>The <em>only</em> way to construct <code class="highlighter-rouge">ReflectT/F</code> is by showing (a proof) of <code class="highlighter-rouge">P/¬P</code>,
meaning invertion on <code class="highlighter-rouge">reflect P bool</code> can give us back the evidence.</p>

<p><code class="highlighter-rouge">iff_reflect</code> give us <code class="highlighter-rouge">eqbP</code>.</p>

<div class="language-coq highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
</pre></td><td class="rouge-code"><pre><span class="k">Lemma</span><span class="w"> </span><span class="no">eqbP</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="err">∀</span><span class="no">n</span><span class="w"> </span><span class="no">m</span><span class="o">,</span><span class="w"> </span><span class="no">reflect</span><span class="w"> </span><span class="o">(</span><span class="no">n</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="no">m</span><span class="o">)</span><span class="w"> </span><span class="o">(</span><span class="no">n</span><span class="w"> </span><span class="o">=?</span><span class="w"> </span><span class="no">m</span><span class="o">).</span><span class="w">
</span><span class="k">Proof</span><span class="pi">.</span><span class="w">
  </span><span class="kp">intros</span><span class="w"> </span><span class="no">n</span><span class="w"> </span><span class="no">m</span><span class="pi">.</span><span class="w"> </span><span class="kp">apply</span><span class="w"> </span><span class="no">iff_reflect</span><span class="pi">.</span><span class="w"> </span><span class="kp">rewrite</span><span class="w"> </span><span class="no">eqb_eq</span><span class="pi">.</span><span class="w"> </span><span class="ne">reflexivity</span><span class="pi">.</span><span class="w">
</span><span class="k">Qed</span><span class="pi">.</span><span class="w">
</span></pre></td></tr></tbody></table></code></pre></div></div>

<p>This gives us a small gain in convenience: we immediately give the <code class="highlighter-rouge">Prop</code> from <code class="highlighter-rouge">bool</code>, no need to <code class="highlighter-rouge">rewrite</code>.</p>
<blockquote>
  <p>Proof Engineering Hacks…</p>
</blockquote>

<h3 id="ssreflect---small-scale-reflection">SSReflect - small-scale reflection</h3>

<blockquote>
  <p>a Coq library
used to prove 4-color theorem…!
simplify small proof steps with boolean computations. (somewhat automation with decision procedures)</p>
</blockquote>

<h2 id="extended-exercise-a-verified-regular-expression-matcher">Extended Exercise: A Verified Regular-Expression Matcher</h2>

<blockquote>
  <p>we have defined a <em>match relation</em> that can <em>prove</em> a regex matches a string.
but it does not give us a <em>program</em> that can <em>run</em> to determine a match automatically…</p>
</blockquote>

<blockquote>
  <p>we hope to translate <em>inductive rules (for constructing evidence)</em> to <em>recursive fn</em>.
however, since <code class="highlighter-rouge">reg_exp</code> is recursive, Coq won’t accept it always terminates</p>
</blockquote>

<p>theoritically, the regex = DFA so it is decidable and halt.
technically, it only halts on finite strings but not infinite strings. 
(and infinite strings are probably beyond the scope of halting problem?)</p>

<blockquote>
  <p>Heavily-optimized regex matcher = translating into <em>state machine</em> e.g. NFA/DFA.
Here we took a <em>derivative</em> approach which operates purely on string.</p>
</blockquote>

<div class="language-coq highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
</pre></td><td class="rouge-code"><pre><span class="k">Require</span><span class="w"> </span><span class="k">Export</span><span class="w"> </span><span class="nn">Coq</span><span class="p">.</span><span class="nn">Strings</span><span class="p">.</span><span class="no">Ascii</span><span class="pi">.</span><span class="w">
</span><span class="k">Definition</span><span class="w"> </span><span class="no">string</span><span class="w"> </span><span class="p">:=</span><span class="w"> </span><span class="no">list</span><span class="w"> </span><span class="no">ascii</span><span class="pi">.</span><span class="w">
</span></pre></td></tr></tbody></table></code></pre></div></div>

<p>Coq 标准库中的 ASCII 字符串也是归纳定义的，不过我们这里为了之前定义的 match relation 用 <code class="highlighter-rouge">list ascii</code>.</p>

<blockquote>
  <p>to define regex matcher over <code class="highlighter-rouge">list X</code> i.e. polymorphic lists.
we need to be able to <em>test equality</em> for each <code class="highlighter-rouge">X</code> etc.</p>
</blockquote>

<h3 id="rules--derivatives">Rules &amp; Derivatives.</h3>

<p>Check paper <a href="">Regular-expression derivatives reexamined - JFP 09</a> as well.</p>

<p><code class="highlighter-rouge">app</code> and <code class="highlighter-rouge">star</code> are the hardest ones.</p>

<h4 id="lets-take-app-as-an-example">Let’s take <code class="highlighter-rouge">app</code> as an example</h4>

<h5 id="1-等价-helper">1. 等价 helper</h5>

<div class="language-coq highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
</pre></td><td class="rouge-code"><pre><span class="k">Lemma</span><span class="w"> </span><span class="no">app_exists</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="err">∀</span><span class="o">(</span><span class="no">s</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="no">string</span><span class="o">)</span><span class="w"> </span><span class="no">re0</span><span class="w"> </span><span class="no">re1</span><span class="o">,</span><span class="w">
    </span><span class="no">s</span><span class="w"> </span><span class="o">=~</span><span class="w"> </span><span class="no">App</span><span class="w"> </span><span class="no">re0</span><span class="w"> </span><span class="no">re1</span><span class="w"> </span><span class="err">↔</span><span class="w"> </span><span class="err">∃</span><span class="no">s0</span><span class="w"> </span><span class="no">s1</span><span class="o">,</span><span class="w"> </span><span class="no">s</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="no">s0</span><span class="w"> </span><span class="o">++</span><span class="w"> </span><span class="no">s1</span><span class="w"> </span><span class="err">∧</span><span class="w"> </span><span class="no">s0</span><span class="w"> </span><span class="o">=~</span><span class="w"> </span><span class="no">re0</span><span class="w"> </span><span class="err">∧</span><span class="w"> </span><span class="no">s1</span><span class="w"> </span><span class="o">=~</span><span class="w"> </span><span class="no">re1</span><span class="pi">.</span><span class="w">
</span></pre></td></tr></tbody></table></code></pre></div></div>

<p>this <em>helper rules</em> is written for the sake of convenience:</p>
<ul>
  <li>the <code class="highlighter-rouge">&lt;-</code> is the definition of <code class="highlighter-rouge">MApp</code>.</li>
  <li>the <code class="highlighter-rouge">-&gt;</code> is the <code class="highlighter-rouge">inversion s =~ App re0 re1</code>.</li>
</ul>

<h5 id="2-app-对于-a--s-的匹配性质">2. <code class="highlighter-rouge">App</code> 对于 <code class="highlighter-rouge">a :: s</code> 的匹配性质</h5>

<div class="language-coq highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
</pre></td><td class="rouge-code"><pre><span class="k">Lemma</span><span class="w"> </span><span class="no">app_ne</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="err">∀</span><span class="o">(</span><span class="no">a</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="no">ascii</span><span class="o">)</span><span class="w"> </span><span class="no">s</span><span class="w"> </span><span class="no">re0</span><span class="w"> </span><span class="no">re1</span><span class="o">,</span><span class="w">
    </span><span class="no">a</span><span class="w"> </span><span class="o">::</span><span class="w"> </span><span class="no">s</span><span class="w"> </span><span class="o">=~</span><span class="w"> </span><span class="o">(</span><span class="no">App</span><span class="w"> </span><span class="no">re0</span><span class="w"> </span><span class="no">re1</span><span class="o">)</span><span class="w"> </span><span class="err">↔</span><span class="w">
    </span><span class="o">([</span><span class="w"> </span><span class="o">]</span><span class="w"> </span><span class="o">=~</span><span class="w"> </span><span class="no">re0</span><span class="w"> </span><span class="err">∧</span><span class="w"> </span><span class="no">a</span><span class="w"> </span><span class="o">::</span><span class="w"> </span><span class="no">s</span><span class="w"> </span><span class="o">=~</span><span class="w"> </span><span class="no">re1</span><span class="o">)</span><span class="w"> </span><span class="err">∨</span><span class="w">
    </span><span class="err">∃</span><span class="no">s0</span><span class="w"> </span><span class="no">s1</span><span class="o">,</span><span class="w"> </span><span class="no">s</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="no">s0</span><span class="w"> </span><span class="o">++</span><span class="w"> </span><span class="no">s1</span><span class="w"> </span><span class="err">∧</span><span class="w"> </span><span class="no">a</span><span class="w"> </span><span class="o">::</span><span class="w"> </span><span class="no">s0</span><span class="w"> </span><span class="o">=~</span><span class="w"> </span><span class="no">re0</span><span class="w"> </span><span class="err">∧</span><span class="w"> </span><span class="no">s1</span><span class="w"> </span><span class="o">=~</span><span class="w"> </span><span class="no">re1</span><span class="pi">.</span><span class="w">
</span></pre></td></tr></tbody></table></code></pre></div></div>
<p>the second rule is more interesting. It states the <em>property</em> of <code class="highlighter-rouge">app</code>:</p>
<blockquote>
  <p>App re0 re1 匹配 a::s 当且仅当  (re0 匹配空字符串 且 a::s 匹配 re1)  或  (s=s0++s1，其中 a::s0 匹配 re0 且 s1 匹配 re1)。</p>
</blockquote>

<p>这两条对后来的证明很有帮助，<code class="highlighter-rouge">app_exists</code> 反演出来的 existential 刚好用在 <code class="highlighter-rouge">app_ne</code> 中.</p>
<blockquote>
  <p>https://github.com/jiangsy/SoftwareFoundation/blob/47543ce8b004cd25d0e1769f7444d57f0e26594d/IndProp.v</p>
</blockquote>

<h5 id="3-定义-derivative-关系">3. 定义 derivative 关系</h5>

<p>the relation <em><code class="highlighter-rouge">re'</code> is a derivative of <code class="highlighter-rouge">re</code> on <code class="highlighter-rouge">a</code></em> is defind as follows:</p>

<div class="language-coq highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
</pre></td><td class="rouge-code"><pre><span class="k">Definition</span><span class="w"> </span><span class="no">is_der</span><span class="w"> </span><span class="no">re</span><span class="w"> </span><span class="o">(</span><span class="no">a</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="no">ascii</span><span class="o">)</span><span class="w"> </span><span class="no">re'</span><span class="w"> </span><span class="p">:=</span><span class="w">
  </span><span class="err">∀</span><span class="no">s</span><span class="o">,</span><span class="w"> </span><span class="no">a</span><span class="w"> </span><span class="o">::</span><span class="w"> </span><span class="no">s</span><span class="w"> </span><span class="o">=~</span><span class="w"> </span><span class="no">re</span><span class="w"> </span><span class="err">↔</span><span class="w"> </span><span class="no">s</span><span class="w"> </span><span class="o">=~</span><span class="w"> </span><span class="no">re'</span><span class="pi">.</span><span class="w">
</span></pre></td></tr></tbody></table></code></pre></div></div>

<h5 id="4-实现-derive">4. 实现 derive</h5>

<p>Now we can impl <code class="highlighter-rouge">derive</code> by follwing <code class="highlighter-rouge">2</code>, the property.
In paper we have:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
</pre></td><td class="rouge-code"><pre>∂ₐ(r · s) = ∂ₐr · s + ν(r) · ∂ₐs       -- subscriprt "a" meaning "respective to a" 

where 
  ν(r) = nullable(r) ? ε : ∅ 
</pre></td></tr></tbody></table></code></pre></div></div>

<p>In our Coq implementation, <code class="highlighter-rouge">nullable(r) == match_eps(r)</code>,</p>

<p>Since we know that 
<code class="highlighter-rouge">∀r, ∅ · r = ∅</code>, 
<code class="highlighter-rouge">∀r, ε · r = r</code>, 
we can be more straightforward by expanding out <code class="highlighter-rouge">v(r)</code>:</p>

<div class="language-coq highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
</pre></td><td class="rouge-code"><pre><span class="k">Fixpoint</span><span class="w"> </span><span class="no">derive</span><span class="w"> </span><span class="o">(</span><span class="no">a</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="no">ascii</span><span class="o">)</span><span class="w"> </span><span class="o">(</span><span class="no">re</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="o">@</span><span class="no">reg_exp</span><span class="w"> </span><span class="no">ascii</span><span class="o">)</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="o">@</span><span class="no">reg_exp</span><span class="w"> </span><span class="no">ascii</span><span class="w"> </span><span class="p">:=</span><span class="w">
</span><span class="o">...</span><span class="w">
 </span><span class="o">|</span><span class="w"> </span><span class="no">App</span><span class="w"> </span><span class="no">r1</span><span class="w"> </span><span class="no">r2</span><span class="w"> </span><span class="p">=&gt;</span><span class="w"> </span><span class="kr">if</span><span class="w"> </span><span class="no">match_eps</span><span class="w"> </span><span class="no">r1</span><span class="w">                            </span><span class="c">(** nullable(r) ? **)</span><span class="w">
      </span><span class="kr">then</span><span class="w"> </span><span class="no">Union</span><span class="w"> </span><span class="o">(</span><span class="no">App</span><span class="w"> </span><span class="o">(</span><span class="no">derive</span><span class="w"> </span><span class="no">a</span><span class="w"> </span><span class="no">r1</span><span class="o">)</span><span class="w"> </span><span class="no">r2</span><span class="o">)</span><span class="w"> </span><span class="o">(</span><span class="no">derive</span><span class="w"> </span><span class="no">a</span><span class="w"> </span><span class="no">r2</span><span class="o">)</span><span class="w">      </span><span class="c">(**  ∂ₐr · s + ∂ₐs **)</span><span class="w">
      </span><span class="kr">else</span><span class="w"> </span><span class="no">App</span><span class="w"> </span><span class="o">(</span><span class="no">derive</span><span class="w"> </span><span class="no">a</span><span class="w"> </span><span class="no">r1</span><span class="o">)</span><span class="w"> </span><span class="no">r2</span><span class="w">                            </span><span class="c">(**  ∂ₐr · s       **)</span><span class="w">
</span></pre></td></tr></tbody></table></code></pre></div></div>


                <hr style="visibility: hidden;">
                <ul class="pager">
                    
                    <li class="previous">
                        <a href="/2019/01/06/sf-lf-06-logic/" data-toggle="tooltip" data-placement="top" title="「SF-LC」6 Logic">
                        Previous<br>
                        <span>「SF-LC」6 Logic</span>
                        </a>
                    </li>
                    
                    
                    <li class="next">
                        <a href="/2019/01/08/sf-lf-08-map/" data-toggle="tooltip" data-placement="top" title="「SF-LC」8 Maps">
                        Next<br>
                        <span>「SF-LC」8 Maps</span>
                        </a>
                    </li>
                    
                </ul>
                <hr style="visibility: hidden;">

                
                <!-- disqus 评论框 start -->
                <div class="comment">
                    <div id="disqus_thread" class="disqus-thread"></div>
                </div>
                <!-- disqus 评论框 end -->
                

                
            </div>  

    <!-- Side Catalog Container -->
        

    <!-- Sidebar Container -->
            <div class="
                col-lg-8 col-lg-offset-2
                col-md-10 col-md-offset-1
                sidebar-container">

                <!-- Featured Tags -->
                


<section>
    
        <hr class="hidden-sm hidden-xs">
    
    <h5><a href="/archive/">FEATURED TAGS</a></h5>
    <div class="tags">
        
        
        
        </a>
        
        
                <a data-sort="0065" 
                    href="/archive/?tag=%E7%9F%A5%E4%B9%8E"
                    title="知乎"
                    rel="10">知乎</a>
        
                <a data-sort="0036" 
                    href="/archive/?tag=%E7%AC%94%E8%AE%B0"
                    title="笔记"
                    rel="39">笔记</a>
        
                <a data-sort="0039" 
                    href="/archive/?tag=Coq"
                    title="Coq"
                    rel="36">Coq</a>
        
                <a data-sort="0039" 
                    href="/archive/?tag=SF+%28%E8%BD%AF%E4%BB%B6%E5%9F%BA%E7%A1%80%29"
                    title="SF (软件基础)"
                    rel="36">SF (软件基础)</a>
        
                <a data-sort="0056" 
                    href="/archive/?tag=PLF+%28%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80%29"
                    title="PLF (编程语言基础)"
                    rel="19">PLF (编程语言基础)</a>
        
                <a data-sort="0056" 
                    href="/archive/?tag=Web"
                    title="Web"
                    rel="19">Web</a>
        
                <a data-sort="0059" 
                    href="/archive/?tag=LF+%28%E9%80%BB%E8%BE%91%E5%9F%BA%E7%A1%80%29"
                    title="LF (逻辑基础)"
                    rel="16">LF (逻辑基础)</a>
        
                <a data-sort="0068" 
                    href="/archive/?tag=UX%2FUI"
                    title="UX/UI"
                    rel="7">UX/UI</a>
        
                <a data-sort="0069" 
                    href="/archive/?tag=%E4%BA%A7%E5%93%81"
                    title="产品"
                    rel="6">产品</a>
        
                <a data-sort="0069" 
                    href="/archive/?tag=PWA"
                    title="PWA"
                    rel="6">PWA</a>
        
                <a data-sort="0071" 
                    href="/archive/?tag=JavaScript"
                    title="JavaScript"
                    rel="4">JavaScript</a>
        
                <a data-sort="0071" 
                    href="/archive/?tag=Slides"
                    title="Slides"
                    rel="4">Slides</a>
        
                <a data-sort="0072" 
                    href="/archive/?tag=%E7%94%9F%E6%B4%BB"
                    title="生活"
                    rel="3">生活</a>
        
                <a data-sort="0072" 
                    href="/archive/?tag=%E8%AF%91"
                    title="译"
                    rel="3">译</a>
        
                <a data-sort="0072" 
                    href="/archive/?tag=%E9%98%BF%E9%87%8C"
                    title="阿里"
                    rel="3">阿里</a>
        
                <a data-sort="0072" 
                    href="/archive/?tag=%F0%9F%87%AC%F0%9F%87%A7"
                    title="🇬🇧"
                    rel="3">🇬🇧</a>
        
                <a data-sort="0072" 
                    href="/archive/?tag=Vim"
                    title="Vim"
                    rel="3">Vim</a>
        
                <a data-sort="0073" 
                    href="/archive/?tag=%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6"
                    title="计算机科学"
                    rel="2">计算机科学</a>
        
                <a data-sort="0073" 
                    href="/archive/?tag=%E8%AE%A1%E7%AE%97%E7%90%86%E8%AE%BA"
                    title="计算理论"
                    rel="2">计算理论</a>
        
                <a data-sort="0073" 
                    href="/archive/?tag=CSS"
                    title="CSS"
                    rel="2">CSS</a>
        
                <a data-sort="0073" 
                    href="/archive/?tag=Wechat"
                    title="Wechat"
                    rel="2">Wechat</a>
        
                <a data-sort="0073" 
                    href="/archive/?tag=hUX+%E9%9A%8F%E6%83%B3%E5%BD%95"
                    title="hUX 随想录"
                    rel="2">hUX 随想录
    </div>
</section>


                <!-- Friends Blog -->
                
<hr>
<h5>FRIENDS</h5>
<ul class="list-inline">
  
  <li><a href="http://mida.re/">乱序</a></li>
  
  <li><a href="http://qianduan.guru/">前端外刊评论</a></li>
  
  <li><a href="http://lingyu.wang/">天镶的博客</a></li>
  
  <li><a href="http://hmqk1995.github.io">Luke 的自留地</a></li>
  
  <li><a href="http://ebnbin.com/">Ebn's Blog</a></li>
  
  <li><a href="http://blog.smdcn.net">SmdCn's Blog</a></li>
  
  <li><a href="https://www.ruoyaowu.com/">David's Game</a></li>
  
  <li><a href="http://dhong.co">DHong Say</a></li>
  
  <li><a href="http://ingf.github.io/">尹峰以为</a></li>
  
  <li><a href="http://xieminis.me/">解旻的博客</a></li>
  
</ul>

            </div>
        </div>
    </div>
</article>

<!-- add support for mathjax by voleking-->






<!-- disqus 公共JS代码 start (一个网页只需插入一次) -->
<script type="text/javascript">
    /* * * CONFIGURATION VARIABLES * * */
    var disqus_shortname = "hux";
    var disqus_identifier = "/2019/01/07/sf-lf-07-indprop";
    var disqus_url = "http://localhost:4000/2019/01/07/sf-lf-07-indprop/";

    (function() {
        var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
        dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
        (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
    })();
</script>
<!-- disqus 公共JS代码 end -->




<!-- async load function -->
<script>
    function async(u, c) {
      var d = document, t = 'script',
          o = d.createElement(t),
          s = d.getElementsByTagName(t)[0];
      o.src = u;
      if (c) { o.addEventListener('load', function (e) { c(null, e); }, false); }
      s.parentNode.insertBefore(o, s);
    }
</script>
<!-- anchor-js, Doc:http://bryanbraun.github.io/anchorjs/ -->
<script>
    async("//cdnjs.cloudflare.com/ajax/libs/anchor-js/1.1.1/anchor.min.js",function(){
        anchors.options = {
          visible: 'hover',
          placement: 'right',
          // icon: '#'
        };
        anchors.add().remove('.intro-header h1').remove('.subheading').remove('.sidebar-container h5');
    })
</script>
<style>
    /* place left on bigger screen */
    @media all and (min-width: 800px) {
        .anchorjs-link{
            position: absolute;
            left: -0.75em;
            font-size: 1.1em;
            margin-top : -0.1em;
        }
    }
</style>



    <!-- Footer -->
<footer>
    <div class="container">
        <div class="row">
            <div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1">
                <!-- SNS Link -->
                


<ul class="list-inline text-center">


  
  
  <li>
    <a href="https://twitter.com/huxpro">
      <span class="fa-stack fa-lg">
        <i class="fa fa-circle fa-stack-2x"></i>
        <i class="fa fa-twitter fa-stack-1x fa-inverse"></i>
      </span>
    </a>
  </li>
  
  
  <li>
    <a target="_blank" href="https://www.zhihu.com/people/huxpro">
      <span class="fa-stack fa-lg">
        <i class="fa fa-circle fa-stack-2x"></i>
        <i class="fa  fa-stack-1x fa-inverse">知</i>
      </span>
    </a>
  </li>
  
  
  <li>
    <a target="_blank" href="http://weibo.com/huxpro">
      <span class="fa-stack fa-lg">
        <i class="fa fa-circle fa-stack-2x"></i>
        <i class="fa fa-weibo fa-stack-1x fa-inverse"></i>
      </span>
    </a>
  </li>
  
  
  
  <li>
    <a target="_blank" href="https://github.com/huxpro">
      <span class="fa-stack fa-lg">
        <i class="fa fa-circle fa-stack-2x"></i>
        <i class="fa fa-github fa-stack-1x fa-inverse"></i>
      </span>
    </a>
  </li>
  
  
</ul>

                <p class="copyright text-muted">
                    Copyright &copy; lxd's Blog 2019
                    <br>
                    Powered by <a href="http://huangxuan.me">Hux Blog</a> |
                    <iframe
                        style="margin-left: 2px; margin-bottom:-5px;"
                        frameborder="0" scrolling="0" width="100px" height="20px"
                        src="https://ghbtns.com/github-btn.html?user=huxpro&repo=huxpro.github.io&type=star&count=true" >
                    </iframe>
                </p>
            </div>
        </div>
    </div>
</footer>

<!-- jQuery -->
<script src="/js/jquery.min.js "></script>

<!-- Bootstrap Core JavaScript -->
<!-- Currently, only navbar scroll-down effect at desktop still depends on this -->
<script src="/js/bootstrap.min.js "></script>

<!-- Custom Theme JavaScript -->
<script src="/js/hux-blog.min.js "></script>

<!-- Service Worker -->

<script src="/js/snackbar.js "></script>
<script src="/js/sw-registration.js "></script>


<!-- async load function -->
<script>
    function async(u, c) {
      var d = document, t = 'script',
          o = d.createElement(t),
          s = d.getElementsByTagName(t)[0];
      o.src = u;
      if (c) { o.addEventListener('load', function (e) { c(null, e); }, false); }
      s.parentNode.insertBefore(o, s);
    }
</script>

<!--
     Because of the native support for backtick-style fenced code blocks
     right within the Markdown is landed in Github Pages,
     From V1.6, There is no need for Highlight.js,
     so Huxblog drops it officially.

     - https://github.com/blog/2100-github-pages-now-faster-and-simpler-with-jekyll-3-0
     - https://help.github.com/articles/creating-and-highlighting-code-blocks/
     - https://github.com/jneen/rouge/wiki/list-of-supported-languages-and-lexers
-->
<!--
    <script>
        async("http://cdn.bootcss.com/highlight.js/8.6/highlight.min.js", function(){
            hljs.initHighlightingOnLoad();
        })
    </script>
    <link href="http://cdn.bootcss.com/highlight.js/8.6/styles/github.min.css" rel="stylesheet">
-->





<!--fastClick.js -->
<script>
    async("//cdnjs.cloudflare.com/ajax/libs/fastclick/1.0.6/fastclick.min.js", function(){
        var $nav = document.querySelector("nav");
        if($nav) FastClick.attach($nav);
    })
</script>


<!-- Google Analytics -->

<script>
    // dynamic User by Hux
    var _gaId = 'UA-49627206-1';
    var _gaDomain = 'huangxuan.me';

    // Originial
    (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
    (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
    m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
    })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

    ga('create', _gaId, _gaDomain);
    ga('send', 'pageview');
</script>



<!-- Baidu Tongji -->



<!-- Side Catalog -->



<!-- Multi-Lingual -->




<!-- Image to hack wechat -->
<img src="/img/icon_wechat.png" width="0" height="0" />
<!-- Migrate from head to bottom, no longer block render and still work -->

</body>

</html>
