<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="google-site-verification" content="xBT4GhYoi5qRD5tr338pgPM5OWHHIDR6mNg1a3euekI" />
    <meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover">
    <meta name="description" content="关于程序与设计、黑客与画家 | 黄玄，Web & Mobile Lover，Software Engineer，UX Designer | 这里是 @Hux黄玄 的个人博客，与你一起发现更大的世界。">
    <meta name="keywords"  content="黄玄, Hux黄玄, Hux, 鬼栈, huxpro, @huxpro, 黄玄的博客, Hux Blog, 博客, 个人网站, 互联网, Web, JavaScript, 前端, 设计">
    <meta name="theme-color" content="#000000">
    
    <!-- Open Graph -->
    <meta property="og:title" content="「SF-LC」6 Logic - lxd的博客 | lxd Blog">
    
    <meta property="og:type" content="article">
    <meta property="og:description" content="We have seen…

">
    
    <meta property="article:published_time" content="2019-01-06T00:00:00Z">
    
    
    <meta property="article:author" content="Hux">
    
    
    <meta property="article:tag" content="LF (逻辑基础)">
    
    <meta property="article:tag" content="SF (软件基础)">
    
    <meta property="article:tag" content="Coq">
    
    <meta property="article:tag" content="笔记">
    
    
    <meta property="og:image" content="http://localhost:4000/img/avatar-hux-ny.jpg">
    <meta property="og:url" content="http://localhost:4000/2019/01/06/sf-lf-06-logic/">
    <meta property="og:site_name" content="lxd的博客 | lxd Blog">
    
    <title>「SF-LC」6 Logic - lxd的博客 | lxd Blog</title>

    <!-- Web App Manifest -->
    <link rel="manifest" href="/pwa/manifest.json">

    <!-- Favicon -->
    <link rel="shortcut icon" href="/img/favicon.ico">
    
    <!-- Canonical URL -->
    <link rel="canonical" href="http://localhost:4000/2019/01/06/sf-lf-06-logic/">

    <!-- Bootstrap Core CSS -->
    <link rel="stylesheet" href="/css/bootstrap.min.css">

    <!-- Custom CSS -->
    <link rel="stylesheet" href="/css/hux-blog.min.css">

    <!-- Custom Fonts -->
    <!-- <link href="http://maxcdn.bootstrapcdn.com/font-awesome/4.3.0/css/font-awesome.min.css" rel="stylesheet" type="text/css"> -->
    <!-- Hux change font-awesome CDN to qiniu -->
    <link href="//cdnjs.cloudflare.com/ajax/libs/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" type="text/css">


    <!-- HTML5 Shim and Respond.js IE8 support of HTML5 elements and media queries -->
    <!-- WARNING: Respond.js doesn't work if you view the page via file:// -->
    <!--[if lt IE 9]>
        <script src="https://oss.maxcdn.com/libs/html5shiv/3.7.0/html5shiv.js"></script>
        <script src="https://oss.maxcdn.com/libs/respond.js/1.4.2/respond.min.js"></script>
    <![endif]-->

    <!-- ga & ba script hoook -->
    <script></script>
</head>


<!-- hack iOS CSS :active style -->
<body ontouchstart="">

    <!-- Navigation -->

<nav class="navbar navbar-default navbar-custom navbar-fixed-top invert">

    <div class="container-fluid">
        <!-- Brand and toggle get grouped for better mobile display -->
        <div class="navbar-header page-scroll">
            <button type="button" class="navbar-toggle">
                <span class="sr-only">Toggle navigation</span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
            </button>
            <a class="navbar-brand" href="/">lxd's Blog</a>
        </div>

        <!-- Collect the nav links, forms, and other content for toggling -->
        <div id="huxblog_navbar">
            <div class="navbar-collapse">
                <ul class="nav navbar-nav navbar-right">
                    <li>
                        <a href="/">Home</a>
                    </li>
                    
                    
                    
                    
                    <li>
                        <a href="/about/">About</a>
                    </li>
                    
                    
                    
                    <li>
                        <a href="/archive/">Archive</a>
                    </li>
                    
                    
                    
                    
                    
                    
                    
                    
                    
                    
                    
                    
                    
                    
                </ul>
            </div>
        </div>
        <!-- /.navbar-collapse -->
    </div>
    <!-- /.container -->
</nav>
<script>
    // Drop Bootstarp low-performance Navbar
    // Use customize navbar with high-quality material design animation
    // in high-perf jank-free CSS3 implementation
    var $body   = document.body;
    var $toggle = document.querySelector('.navbar-toggle');
    var $navbar = document.querySelector('#huxblog_navbar');
    var $collapse = document.querySelector('.navbar-collapse');

    var __HuxNav__ = {
        close: function(){
            $navbar.className = " ";
            // wait until animation end.
            setTimeout(function(){
                // prevent frequently toggle
                if($navbar.className.indexOf('in') < 0) {
                    $collapse.style.height = "0px"
                }
            },400)
        },
        open: function(){
            $collapse.style.height = "auto"
            $navbar.className += " in";
        }
    }

    // Bind Event
    $toggle.addEventListener('click', function(e){
        if ($navbar.className.indexOf('in') > 0) {
            __HuxNav__.close()
        }else{
            __HuxNav__.open()
        }
    })

    /**
     * Since Fastclick is used to delegate 'touchstart' globally
     * to hack 300ms delay in iOS by performing a fake 'click',
     * Using 'e.stopPropagation' to stop 'touchstart' event from 
     * $toggle/$collapse will break global delegation.
     * 
     * Instead, we use a 'e.target' filter to prevent handler
     * added to document close HuxNav.  
     *
     * Also, we use 'click' instead of 'touchstart' as compromise
     */
    document.addEventListener('click', function(e){
        if(e.target == $toggle) return;
        if(e.target.className == 'icon-bar') return;
        __HuxNav__.close();
    })
</script>


    <!-- Image to hack wechat -->
<!-- <img src="/img/icon_wechat.png" width="0" height="0"> -->
<!-- <img src="/img/home-bg.jpg" width="0" height="0"> -->

<!-- Post Header -->



<style type="text/css">
    header.intro-header{
        position: relative;
        background-image: url('/img/home-bg.jpg');
        background: ;
    }

    
</style>

<header class="intro-header style-text" >

    <div class="header-mask"></div>
    
    <div class="container">
        <div class="row">
            <div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1">
                <div class="post-heading">
                    <div class="tags">
                        
                        <a class="tag" href="/archive/?tag=LF+%28%E9%80%BB%E8%BE%91%E5%9F%BA%E7%A1%80%29" title="LF (逻辑基础)">LF (逻辑基础)</a>
                        
                        <a class="tag" href="/archive/?tag=SF+%28%E8%BD%AF%E4%BB%B6%E5%9F%BA%E7%A1%80%29" title="SF (软件基础)">SF (软件基础)</a>
                        
                        <a class="tag" href="/archive/?tag=Coq" title="Coq">Coq</a>
                        
                        <a class="tag" href="/archive/?tag=%E7%AC%94%E8%AE%B0" title="笔记">笔记</a>
                        
                    </div>
                    <h1>「SF-LC」6 Logic</h1>
                    
                    <h2 class="subheading">Logical Foundations - Logic in Coq</h2>
                    <span class="meta">Posted by Hux on January 6, 2019</span>
                </div>
            </div>
        </div>
    </div>
</header>






<!-- Post Content -->
<article>
    <div class="container">
        <div class="row">

    <!-- Post Container -->
            <div class="
                col-lg-8 col-lg-offset-2
                col-md-10 col-md-offset-1
                post-container">

                <!-- Multi-Lingual -->
                

				<p>We have seen…</p>

<ul>
  <li><em>propositions</em>: factual claims
    <ul>
      <li>equality propositions (<code class="highlighter-rouge">e1 = e2</code>)</li>
      <li>implications (<code class="highlighter-rouge">P → Q</code>)</li>
      <li>quantified propositions (<code class="highlighter-rouge">∀ x, P</code>)</li>
    </ul>
  </li>
  <li><em>proofs</em>: ways of presenting <strong>evidence</strong> for the truth of a proposition</li>
</ul>

<h2 id="prop-type"><code class="highlighter-rouge">Prop</code> type</h2>

<div class="language-coq highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
</pre></td><td class="rouge-code"><pre><span class="k">Check</span><span class="w"> </span><span class="mi">3</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">3</span><span class="o">.</span><span class="w">  </span><span class="c">(* ===&gt; Prop. A provable prop *)</span><span class="w">
</span><span class="k">Check</span><span class="w"> </span><span class="mi">3</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">4</span><span class="o">.</span><span class="w">  </span><span class="c">(* ===&gt; Prop. A unprovable prop *)</span><span class="w">
</span></pre></td></tr></tbody></table></code></pre></div></div>

<p><code class="highlighter-rouge">Prop</code> is <em>first-class entity</em> we can</p>
<ul>
  <li>name it</li>
  <li><em>parametrized</em>!</li>
</ul>

<div class="language-coq highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
</pre></td><td class="rouge-code"><pre><span class="k">Definition</span><span class="w"> </span><span class="no">is_three</span><span class="w"> </span><span class="o">(</span><span class="no">n</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="no">nat</span><span class="o">)</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="kr">Prop</span><span class="w"> </span><span class="p">:=</span><span class="w">
  </span><span class="no">n</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">3</span><span class="o">.</span><span class="w">

</span><span class="k">Check</span><span class="w"> </span><span class="no">is_three</span><span class="pi">.</span><span class="w"> </span><span class="c">(* ===&gt; nat -&gt; Prop *)</span><span class="w">
</span></pre></td></tr></tbody></table></code></pre></div></div>

<h3 id="properties">Properties</h3>

<blockquote>
  <p>In Coq, <em>functions that return propositions</em> are said to define <em>properties</em> of their arguments.</p>
</blockquote>

<div class="language-coq highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
</pre></td><td class="rouge-code"><pre><span class="k">Definition</span><span class="w"> </span><span class="no">injective</span><span class="w"> </span><span class="o">{</span><span class="no">A</span><span class="w"> </span><span class="no">B</span><span class="o">}</span><span class="w"> </span><span class="o">(</span><span class="no">f</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="no">A</span><span class="w"> </span><span class="err">→</span><span class="w"> </span><span class="no">B</span><span class="o">)</span><span class="w"> </span><span class="p">:=</span><span class="w">
  </span><span class="err">∀</span><span class="no">x</span><span class="w"> </span><span class="no">y</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="no">A</span><span class="o">,</span><span class="w"> </span><span class="no">f</span><span class="w"> </span><span class="no">x</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="no">f</span><span class="w"> </span><span class="no">y</span><span class="w"> </span><span class="err">→</span><span class="w"> </span><span class="no">x</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="no">y</span><span class="pi">.</span><span class="w">
</span><span class="k">Lemma</span><span class="w"> </span><span class="no">succ_inj</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="no">injective</span><span class="w"> </span><span class="no">S</span><span class="pi">.</span><span class="w"> </span><span class="c">(* can be read off as "injectivity is a property of S" *)</span><span class="w">
</span><span class="k">Proof</span><span class="pi">.</span><span class="w"> 
  </span><span class="kp">intros</span><span class="w"> </span><span class="no">n</span><span class="w"> </span><span class="no">m</span><span class="w"> </span><span class="no">H</span><span class="pi">.</span><span class="w"> </span><span class="kp">injection</span><span class="w"> </span><span class="no">H</span><span class="w"> </span><span class="kr">as</span><span class="w"> </span><span class="no">H1</span><span class="pi">.</span><span class="w"> </span><span class="kp">apply</span><span class="w"> </span><span class="no">H1</span><span class="pi">.</span><span class="w"> </span><span class="k">Qed</span><span class="pi">.</span><span class="w">
</span></pre></td></tr></tbody></table></code></pre></div></div>

<p>The equality operator <code class="highlighter-rouge">=</code> is also a function that returns a <code class="highlighter-rouge">Prop</code>. (property: <em>equality</em>)</p>

<div class="language-coq highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre></td><td class="rouge-code"><pre><span class="k">Check</span><span class="w"> </span><span class="o">@</span><span class="no">eq</span><span class="pi">.</span><span class="w"> </span><span class="c">(* ===&gt; forall A : Type, A -&gt; A -&gt; Prop *)</span><span class="w">
</span></pre></td></tr></tbody></table></code></pre></div></div>

<p>Theroems are types, and proofs are existentials.</p>

<h2 id="slide-qa---1">Slide Q&amp;A - 1.</h2>

<ol>
  <li><code class="highlighter-rouge">Prop</code></li>
  <li><code class="highlighter-rouge">Prop</code></li>
  <li><code class="highlighter-rouge">Prop</code></li>
  <li>Not typeable</li>
  <li><code class="highlighter-rouge">nat -&gt; nat</code></li>
  <li><code class="highlighter-rouge">nat -&gt; Prop</code></li>
  <li>(3)</li>
</ol>

<p>think that Big Lambda (the type abstraction) works at type level, accepts type var, substitute and reture a type.
<code class="highlighter-rouge">forall</code> in Coq is same (the concrete syntax) and only typecheck with <code class="highlighter-rouge">Type</code> or its subtype <code class="highlighter-rouge">Set</code> &amp; <code class="highlighter-rouge">Prop</code>.</p>

<div class="language-coq highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
</pre></td><td class="rouge-code"><pre><span class="k">Check</span><span class="w"> </span><span class="o">(</span><span class="err">∀</span><span class="no">n</span><span class="p">:</span><span class="no">nat</span><span class="o">,</span><span class="w"> </span><span class="no">S</span><span class="w"> </span><span class="o">(</span><span class="no">pred</span><span class="w"> </span><span class="no">n</span><span class="o">)).</span><span class="w">  </span><span class="c">(* not typeable *)</span><span class="w">

</span><span class="k">Definition</span><span class="w"> </span><span class="no">foo</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="o">(</span><span class="kr">forall</span><span class="w"> </span><span class="no">n</span><span class="p">:</span><span class="no">nat</span><span class="o">,</span><span class="w"> </span><span class="no">bool</span><span class="o">)</span><span class="w"> </span><span class="c">(* foo: nat -&gt; bool *)</span><span class="w">
  </span><span class="p">:=</span><span class="w"> </span><span class="kr">fun</span><span class="w"> </span><span class="no">x</span><span class="w"> </span><span class="p">=&gt;</span><span class="w"> </span><span class="no">true</span><span class="pi">.</span><span class="w">
</span></pre></td></tr></tbody></table></code></pre></div></div>

<h2 id="logical-connectives">Logical Connectives</h2>

<blockquote>
  <p>noticed that connectives symbols are “unicodize” in book and spacemacs.</p>
</blockquote>

<h3 id="conjuction-logical-and">Conjuction (logical and)</h3>

<p><code class="highlighter-rouge">and</code> is just binary <code class="highlighter-rouge">Prop -&gt; Prop -&gt; Prop</code> and associative.</p>

<div class="language-coq highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
</pre></td><td class="rouge-code"><pre><span class="k">Print</span><span class="w"> </span><span class="s2">"/</span><span class="se">\"</span><span class="s2">.
Inductive and (A B : Prop) : Prop :=  conj : A -&gt; B -&gt; A /</span><span class="err">\</span><span class="s2"> B
Check and. (* ===&gt; and : Prop -&gt; Prop -&gt; Prop *)
</span></pre></td></tr></tbody></table></code></pre></div></div>

<h4 id="and-introduction">and introduction</h4>

<div class="language-coq highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
</pre></td><td class="rouge-code"><pre><span class="k">Lemma</span><span class="w"> </span><span class="no">and_intro</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="kr">forall</span><span class="w"> </span><span class="no">A</span><span class="w"> </span><span class="no">B</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="kr">Prop</span><span class="o">,</span><span class="w"> </span><span class="no">A</span><span class="w"> </span><span class="p">-&gt;</span><span class="w"> </span><span class="no">B</span><span class="w"> </span><span class="p">-&gt;</span><span class="w"> </span><span class="no">A</span><span class="w"> </span><span class="o">/\</span><span class="w"> </span><span class="no">B</span><span class="pi">.</span><span class="w">
</span><span class="k">Proof</span><span class="pi">.</span><span class="w">
  </span><span class="kp">intros</span><span class="w"> </span><span class="no">A</span><span class="w"> </span><span class="no">B</span><span class="w"> </span><span class="no">HA</span><span class="w"> </span><span class="no">HB</span><span class="pi">.</span><span class="w"> </span><span class="kp">split</span><span class="pi">.</span><span class="w">
  </span><span class="o">-</span><span class="w"> </span><span class="kp">apply</span><span class="w"> </span><span class="no">HA</span><span class="pi">.</span><span class="w">
  </span><span class="o">-</span><span class="w"> </span><span class="kp">apply</span><span class="w"> </span><span class="no">HB</span><span class="pi">.</span><span class="w">
</span><span class="k">Qed</span><span class="pi">.</span><span class="w">
</span></pre></td></tr></tbody></table></code></pre></div></div>
<blockquote>
  <p>To prove a conjunction,</p>
  <ul>
    <li>use the <code class="highlighter-rouge">split</code> tactic. It will generate two subgoals,</li>
    <li>or use <code class="highlighter-rouge">apply and_intro.</code>, which match the conclusion and give its two premises as your subgoals.</li>
  </ul>
</blockquote>

<h4 id="and-elimination">and elimination</h4>

<p>if we already have a proof of <code class="highlighter-rouge">and</code>, <code class="highlighter-rouge">destruct</code> can give us both.</p>

<div class="language-coq highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
</pre></td><td class="rouge-code"><pre><span class="k">Lemma</span><span class="w"> </span><span class="no">and_example2'</span><span class="w"> </span><span class="p">:</span><span class="w">
  </span><span class="err">∀</span><span class="no">n</span><span class="w"> </span><span class="no">m</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="no">nat</span><span class="o">,</span><span class="w"> </span><span class="no">n</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="w"> </span><span class="err">∧</span><span class="w"> </span><span class="no">m</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="w"> </span><span class="err">→</span><span class="w"> </span><span class="no">n</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="no">m</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="o">.</span><span class="w">
</span><span class="k">Proof</span><span class="pi">.</span><span class="w">
  </span><span class="kp">intros</span><span class="w"> </span><span class="no">n</span><span class="w"> </span><span class="no">m</span><span class="w"> </span><span class="o">[</span><span class="no">Hn</span><span class="w"> </span><span class="no">Hm</span><span class="o">].</span><span class="w"> </span><span class="c">(* = intro H. destruct H. *)</span><span class="w">
  </span><span class="kp">rewrite</span><span class="w"> </span><span class="no">Hn</span><span class="pi">.</span><span class="w"> </span><span class="kp">rewrite</span><span class="w"> </span><span class="no">Hm</span><span class="pi">.</span><span class="w"> </span><span class="ne">reflexivity</span><span class="pi">.</span><span class="w"> </span><span class="k">Qed</span><span class="pi">.</span><span class="w">  </span><span class="c">(* you could use only one *)</span><span class="w">
</span></pre></td></tr></tbody></table></code></pre></div></div>

<p>Instead of packing into conjunction <code class="highlighter-rouge">∀n m : nat, n = 0 ∧ m = 0 → n + m = 0.</code>
why not two separate premises?      <code class="highlighter-rouge">∀n m : nat, n = 0 -&gt; m = 0 → n + m = 0.</code> 
Both are fine in this case but conjunction are useful as intermediate step etc.</p>

<blockquote>
  <p>Coq Intensive Q: why <code class="highlighter-rouge">destruct</code> can work on <code class="highlighter-rouge">and</code>? is <code class="highlighter-rouge">and</code> inductively defined?
A: Yes.</p>
</blockquote>

<h3 id="disjunction-locial-or">Disjunction (locial or)</h3>

<h4 id="or-elimination">or elimination</h4>

<p>We need do case analysis (either <code class="highlighter-rouge">P</code> or <code class="highlighter-rouge">Q</code> should be able to prove the theroem separately!)</p>

<div class="language-coq highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
</pre></td><td class="rouge-code"><pre><span class="k">Lemma</span><span class="w"> </span><span class="no">or_example</span><span class="w"> </span><span class="p">:</span><span class="w">
  </span><span class="kr">forall</span><span class="w"> </span><span class="no">n</span><span class="w"> </span><span class="no">m</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="no">nat</span><span class="o">,</span><span class="w"> </span><span class="no">n</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="w"> </span><span class="o">\/</span><span class="w"> </span><span class="no">m</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="w"> </span><span class="p">-&gt;</span><span class="w"> </span><span class="no">n</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="no">m</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="o">.</span><span class="w">
</span><span class="k">Proof</span><span class="pi">.</span><span class="w">
  </span><span class="c">(* This pattern implicitly does case analysis on [n = 0 \/ m = 0] *)</span><span class="w">
  </span><span class="kp">intros</span><span class="w"> </span><span class="no">n</span><span class="w"> </span><span class="no">m</span><span class="w"> </span><span class="o">[</span><span class="no">Hn</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="no">Hm</span><span class="o">].</span><span class="w"> </span><span class="c">(* = intro H. destruct H. *)</span><span class="w">
  </span><span class="o">-</span><span class="w"> </span><span class="c">(* Here, [n = 0] *)</span><span class="w"> </span><span class="kp">rewrite</span><span class="w"> </span><span class="no">Hn</span><span class="pi">.</span><span class="w"> </span><span class="ne">reflexivity</span><span class="pi">.</span><span class="w">
  </span><span class="o">-</span><span class="w"> </span><span class="c">(* Here, [m = 0] *)</span><span class="w"> </span><span class="kp">rewrite</span><span class="w"> </span><span class="no">Hm</span><span class="pi">.</span><span class="w"> </span><span class="kp">rewrite</span><span class="w"> </span><span class="o">&lt;-</span><span class="w"> </span><span class="no">mult_n_O</span><span class="pi">.</span><span class="w"> </span><span class="ne">reflexivity</span><span class="pi">.</span><span class="w">
</span><span class="k">Qed</span><span class="pi">.</span><span class="w">
</span></pre></td></tr></tbody></table></code></pre></div></div>

<h4 id="or-introduction">or introduction</h4>

<p>When trying to establish (intro into conclusion) an <code class="highlighter-rouge">or</code>, using <code class="highlighter-rouge">left</code> or <code class="highlighter-rouge">right</code> to pick one side to prove is sufficient.</p>

<div class="language-coq highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
</pre></td><td class="rouge-code"><pre><span class="k">Lemma</span><span class="w"> </span><span class="no">or_intro</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="kr">forall</span><span class="w"> </span><span class="no">A</span><span class="w"> </span><span class="no">B</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="kr">Prop</span><span class="o">,</span><span class="w"> </span><span class="no">A</span><span class="w"> </span><span class="p">-&gt;</span><span class="w"> </span><span class="no">A</span><span class="w"> </span><span class="o">\/</span><span class="w"> </span><span class="no">B</span><span class="pi">.</span><span class="w">
</span><span class="k">Proof</span><span class="pi">.</span><span class="w">
  </span><span class="kp">intros</span><span class="w"> </span><span class="no">A</span><span class="w"> </span><span class="no">B</span><span class="w"> </span><span class="no">HA</span><span class="pi">.</span><span class="w">
  </span><span class="no">left</span><span class="pi">.</span><span class="w">  </span><span class="c">(* tactics *)</span><span class="w">
  </span><span class="kp">apply</span><span class="w"> </span><span class="no">HA</span><span class="pi">.</span><span class="w">
</span><span class="k">Qed</span><span class="pi">.</span><span class="w">
</span></pre></td></tr></tbody></table></code></pre></div></div>

<h3 id="falsehood-and-negation">Falsehood and negation</h3>

<h4 id="false">False?</h4>

<p>Recall the <em>princple of explosion</em>: it asserts that, if we assume a <em>contradiction</em>, then any other proposition can be derived.
we could define <code class="highlighter-rouge">¬ P</code> (“not P”) as <code class="highlighter-rouge">∀ Q, P → Q.</code>.</p>

<blockquote>
  <p>Coq actually makes a slightly different (but equivalent) choice, defining <code class="highlighter-rouge">¬ P as P → False</code>, where <code class="highlighter-rouge">False</code> is a specific <em>contradictory proposition</em> defined in the standard library.</p>
</blockquote>

<div class="language-coq highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
</pre></td><td class="rouge-code"><pre><span class="k">Definition</span><span class="w"> </span><span class="no">not</span><span class="w"> </span><span class="o">(</span><span class="no">P</span><span class="p">:</span><span class="kr">Prop</span><span class="o">)</span><span class="w"> </span><span class="p">:=</span><span class="w"> </span><span class="no">P</span><span class="w"> </span><span class="err">→</span><span class="w"> </span><span class="no">False</span><span class="pi">.</span><span class="w">
</span><span class="k">Notation</span><span class="w"> </span><span class="s2">"¬x"</span><span class="w"> </span><span class="p">:=</span><span class="w"> </span><span class="o">(</span><span class="no">not</span><span class="w"> </span><span class="no">x</span><span class="o">)</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="no">type_scope</span><span class="pi">.</span><span class="w">
</span></pre></td></tr></tbody></table></code></pre></div></div>

<p>Prove the <em>princple of explosion</em>:</p>

<div class="language-coq highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
</pre></td><td class="rouge-code"><pre><span class="k">Theorem</span><span class="w"> </span><span class="no">ex_falso_quodlibet</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="kr">forall</span><span class="w"> </span><span class="o">(</span><span class="no">P</span><span class="p">:</span><span class="kr">Prop</span><span class="o">),</span><span class="w">
  </span><span class="no">False</span><span class="w"> </span><span class="p">-&gt;</span><span class="w"> </span><span class="no">P</span><span class="pi">.</span><span class="w">
</span><span class="k">Proof</span><span class="pi">.</span><span class="w">
  </span><span class="kp">intros</span><span class="w"> </span><span class="no">P</span><span class="w"> </span><span class="no">contra</span><span class="pi">.</span><span class="w">
  </span><span class="kp">destruct</span><span class="w"> </span><span class="no">contra</span><span class="pi">.</span><span class="w">  </span><span class="k">Qed</span><span class="pi">.</span><span class="w">  </span><span class="c">(* 0 cases to prove since ⊥ is not provable. [inversion] also works *)</span><span class="w">
</span></pre></td></tr></tbody></table></code></pre></div></div>

<h4 id="inequality">Inequality</h4>

<div class="language-coq highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre></td><td class="rouge-code"><pre><span class="k">Notation</span><span class="w"> </span><span class="s2">"x &lt;&gt; y"</span><span class="w"> </span><span class="p">:=</span><span class="w"> </span><span class="o">(~(</span><span class="no">x</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="no">y</span><span class="o">)).</span><span class="w">
</span></pre></td></tr></tbody></table></code></pre></div></div>

<p>Same as SML and OCaml (for structural equality, OCaml uses <code class="highlighter-rouge">!=</code> for physical equality.)</p>

<h4 id="proving-of-negation-or-how-to-prove-p">Proving of negation (or how to prove <code class="highlighter-rouge">¬P</code>)</h4>

<p>thinking about as <code class="highlighter-rouge">unfold not</code>, i.e. <code class="highlighter-rouge">P -&gt; False</code>.
so you have an assumptions <code class="highlighter-rouge">P</code> that could be <code class="highlighter-rouge">intros HP.</code> and the residual goal would be simply <code class="highlighter-rouge">False</code>. 
which is usually proved by some kind of contradiction in hypotheses with tactics <code class="highlighter-rouge">discriminate.</code> or <code class="highlighter-rouge">contradiction.</code></p>

<div class="language-coq highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
</pre></td><td class="rouge-code"><pre><span class="k">Theorem</span><span class="w"> </span><span class="no">contradiction_implies_anything</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="kr">forall</span><span class="w"> </span><span class="no">P</span><span class="w"> </span><span class="no">Q</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="kr">Prop</span><span class="o">,</span><span class="w">
  </span><span class="o">(</span><span class="no">P</span><span class="w"> </span><span class="o">/\</span><span class="w"> </span><span class="o">~</span><span class="no">P</span><span class="o">)</span><span class="w"> </span><span class="p">-&gt;</span><span class="w"> </span><span class="no">Q</span><span class="pi">.</span><span class="w">
</span><span class="k">Proof</span><span class="pi">.</span><span class="w">
  </span><span class="kp">intros</span><span class="w"> </span><span class="no">P</span><span class="w"> </span><span class="no">Q</span><span class="w"> </span><span class="o">[</span><span class="no">HP</span><span class="w"> </span><span class="no">HNA</span><span class="o">].</span><span class="w">                 </span><span class="c">(* we could [contradiction.] to end the proof here`*)</span><span class="w">
  </span><span class="kp">unfold</span><span class="w"> </span><span class="no">not</span><span class="w"> </span><span class="kr">in</span><span class="w"> </span><span class="no">HNA</span><span class="pi">.</span><span class="w"> </span><span class="kp">apply</span><span class="w"> </span><span class="no">HNA</span><span class="w"> </span><span class="kr">in</span><span class="w"> </span><span class="no">HP</span><span class="pi">.</span><span class="w">  </span><span class="c">(* HP : False, HNA : P -&gt; False  ⊢  HP: False  *)</span><span class="w">
  </span><span class="kp">destruct</span><span class="w"> </span><span class="no">HP</span><span class="pi">.</span><span class="w">  </span><span class="k">Qed</span><span class="pi">.</span><span class="w">                   </span><span class="c">(* destruct False.  *)</span><span class="w">
</span></pre></td></tr></tbody></table></code></pre></div></div>

<h4 id="tactic-exfalso">Tactic <code class="highlighter-rouge">exfalso.</code></h4>

<blockquote>
  <p>If you are trying to prove a goal that is nonsensical (e.g., the goal state is <code class="highlighter-rouge">false = true</code>), apply <code class="highlighter-rouge">ex_falso_quodlibet</code> to change the goal to <code class="highlighter-rouge">False</code>. This makes it easier to use assumptions of the form <code class="highlighter-rouge">¬P</code> that may be available in the context — in particular, assumptions of the form <code class="highlighter-rouge">x≠y</code>.</p>
</blockquote>

<blockquote>
  <p>Since reasoning with <code class="highlighter-rouge">ex_falso_quodlibet</code> is quite common, Coq provides a built-in tactic, <code class="highlighter-rouge">exfalso</code>, for applying it.</p>
</blockquote>

<h2 id="slide-qa---2">Slide Q&amp;A - 2</h2>

<blockquote>
  <p>?<code class="highlighter-rouge">unfold</code> is implicit</p>
</blockquote>

<ol>
  <li>only <code class="highlighter-rouge">destruct</code> (if we consider <code class="highlighter-rouge">intros</code> destruct is also <code class="highlighter-rouge">destruct</code>.), ?<code class="highlighter-rouge">unfold</code></li>
  <li>none (?<code class="highlighter-rouge">unfold</code>)</li>
  <li><code class="highlighter-rouge">left.</code></li>
  <li><code class="highlighter-rouge">destruct</code>, <code class="highlighter-rouge">unfold</code>, <code class="highlighter-rouge">left</code> and <code class="highlighter-rouge">right</code></li>
  <li><code class="highlighter-rouge">discrinminate</code> (or <code class="highlighter-rouge">inversion</code>)</li>
</ol>

<h3 id="truth">Truth</h3>

<div class="language-coq highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
</pre></td><td class="rouge-code"><pre><span class="k">Lemma</span><span class="w"> </span><span class="no">True_is_true</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="no">True</span><span class="pi">.</span><span class="w">
</span><span class="k">Proof</span><span class="pi">.</span><span class="w"> </span><span class="kp">apply</span><span class="w"> </span><span class="no">I</span><span class="pi">.</span><span class="w"> </span><span class="k">Qed</span><span class="pi">.</span><span class="w">
</span></pre></td></tr></tbody></table></code></pre></div></div>

<p><code class="highlighter-rouge">I : True</code> is a predefined Prop…</p>

<h3 id="logical-equivalence">Logical Equivalence</h3>

<p><em>if and only if</em> is just the conjunction of two implications. (so we need <code class="highlighter-rouge">split</code> to get 2 subgoals)</p>

<div class="language-coq highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
</pre></td><td class="rouge-code"><pre><span class="k">Definition</span><span class="w"> </span><span class="no">iff</span><span class="w"> </span><span class="o">(</span><span class="no">P</span><span class="w"> </span><span class="no">Q</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="kr">Prop</span><span class="o">)</span><span class="w"> </span><span class="p">:=</span><span class="w"> </span><span class="o">(</span><span class="no">P</span><span class="w"> </span><span class="err">→</span><span class="w"> </span><span class="no">Q</span><span class="o">)</span><span class="w"> </span><span class="err">∧</span><span class="w"> </span><span class="o">(</span><span class="no">Q</span><span class="w"> </span><span class="err">→</span><span class="w"> </span><span class="no">P</span><span class="o">).</span><span class="w">
</span><span class="k">Notation</span><span class="w"> </span><span class="s2">"P ↔ Q"</span><span class="w"> </span><span class="p">:=</span><span class="w"> </span><span class="o">(</span><span class="no">iff</span><span class="w"> </span><span class="no">P</span><span class="w"> </span><span class="no">Q</span><span class="o">)</span><span class="w">
                    </span><span class="o">(</span><span class="kp">at</span><span class="w"> </span><span class="no">level</span><span class="w"> </span><span class="mi">95</span><span class="o">,</span><span class="w"> </span><span class="no">no</span><span class="w"> </span><span class="no">associativity</span><span class="o">)</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="no">type_scope</span><span class="pi">.</span><span class="w">
</span></pre></td></tr></tbody></table></code></pre></div></div>

<blockquote>
  <p><code class="highlighter-rouge">rewrite</code> and <code class="highlighter-rouge">reflexivity</code> can be used with iff statements, not just equalities.</p>
</blockquote>

<h3 id="existential-quantification">Existential Quantification</h3>

<p>To prove a statement of the form <code class="highlighter-rouge">∃x, P</code>, we must show that <code class="highlighter-rouge">P</code> holds for some specific choice of value for <code class="highlighter-rouge">x</code>, 
known as the <strong>witness</strong> of the existential.</p>

<p>So we explicitly tell Coq which witness <code class="highlighter-rouge">t</code> we have in mind by invoking <code class="highlighter-rouge">exists t</code>.
then all occurences of that “type variable” would be replaced.</p>

<h4 id="intro">Intro</h4>

<div class="language-coq highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
</pre></td><td class="rouge-code"><pre><span class="k">Lemma</span><span class="w"> </span><span class="no">four_is_even</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="kp">exists</span><span class="w"> </span><span class="no">n</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="no">nat</span><span class="o">,</span><span class="w"> </span><span class="mi">4</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="no">n</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="no">n</span><span class="pi">.</span><span class="w">
</span><span class="k">Proof</span><span class="pi">.</span><span class="w">
  </span><span class="kp">exists</span><span class="w"> </span><span class="mi">2</span><span class="o">.</span><span class="w"> </span><span class="ne">reflexivity</span><span class="pi">.</span><span class="w">
</span><span class="k">Qed</span><span class="pi">.</span><span class="w">
</span></pre></td></tr></tbody></table></code></pre></div></div>

<h4 id="elim">Elim</h4>

<p>Below is an interesting question…by intros and destruct we can have equation <code class="highlighter-rouge">n = 4 + m</code> in hypotheses.</p>

<div class="language-coq highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
</pre></td><td class="rouge-code"><pre><span class="k">Theorem</span><span class="w"> </span><span class="no">exists_example_2</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="kr">forall</span><span class="w"> </span><span class="no">n</span><span class="o">,</span><span class="w">
  </span><span class="o">(</span><span class="kp">exists</span><span class="w"> </span><span class="no">m</span><span class="o">,</span><span class="w"> </span><span class="no">n</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">4</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="no">m</span><span class="o">)</span><span class="w"> </span><span class="p">-&gt;</span><span class="w">
  </span><span class="o">(</span><span class="kp">exists</span><span class="w"> </span><span class="no">o</span><span class="o">,</span><span class="w"> </span><span class="no">n</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">2</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="no">o</span><span class="o">).</span><span class="w">
</span><span class="k">Proof</span><span class="pi">.</span><span class="w">
  </span><span class="kp">intros</span><span class="w"> </span><span class="no">n</span><span class="w"> </span><span class="o">[</span><span class="no">m</span><span class="w"> </span><span class="no">Hm</span><span class="o">].</span><span class="w"> </span><span class="c">(* note implicit [destruct] here *)</span><span class="w">
  </span><span class="kp">exists</span><span class="w"> </span><span class="o">(</span><span class="mi">2</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="no">m</span><span class="o">).</span><span class="w">
  </span><span class="kp">apply</span><span class="w"> </span><span class="no">Hm</span><span class="pi">.</span><span class="w">  </span><span class="k">Qed</span><span class="pi">.</span><span class="w">
</span></pre></td></tr></tbody></table></code></pre></div></div>

<h2 id="programming-with-propositions">Programming with Propositions</h2>

<p>Considering writing a common recursive <code class="highlighter-rouge">is_in</code> for polymorphic lists. 
(Though we dont have a polymorphic <code class="highlighter-rouge">=?</code> (<code class="highlighter-rouge">eqb</code>) defined yet)</p>

<div class="language-coq highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
</pre></td><td class="rouge-code"><pre><span class="k">Fixpoint</span><span class="w"> </span><span class="no">is_in</span><span class="w"> </span><span class="o">{</span><span class="no">A</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="kr">Type</span><span class="o">}</span><span class="w"> </span><span class="o">(</span><span class="no">x</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="no">A</span><span class="o">)</span><span class="w"> </span><span class="o">(</span><span class="no">l</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="no">list</span><span class="w"> </span><span class="no">A</span><span class="o">)</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="no">bool</span><span class="w"> </span><span class="p">:=</span><span class="w">
  </span><span class="kr">match</span><span class="w"> </span><span class="no">l</span><span class="w"> </span><span class="kp">with</span><span class="w">
  </span><span class="o">|</span><span class="w"> </span><span class="o">[]</span><span class="w"> </span><span class="p">=&gt;</span><span class="w"> </span><span class="no">false</span><span class="w">
  </span><span class="o">|</span><span class="w"> </span><span class="no">x'</span><span class="w"> </span><span class="o">::</span><span class="w"> </span><span class="no">l'</span><span class="w"> </span><span class="p">=&gt;</span><span class="w"> </span><span class="kr">if</span><span class="w"> </span><span class="o">(</span><span class="no">x'</span><span class="w"> </span><span class="o">=?</span><span class="w"> </span><span class="no">x</span><span class="o">)</span><span class="w"> </span><span class="kr">then</span><span class="w"> </span><span class="no">true</span><span class="w"> </span><span class="kr">else</span><span class="w"> </span><span class="no">is_in</span><span class="w"> </span><span class="no">x</span><span class="w"> </span><span class="no">l'</span><span class="w">
  </span><span class="kr">end</span><span class="pi">.</span><span class="w">
</span></pre></td></tr></tbody></table></code></pre></div></div>

<p>Similarly, we can write this function but with disjunction and return a <code class="highlighter-rouge">Prop</code>!
<em>so we can write function to generate/create statements/propositions!</em> (thx for the idea Prop is first-class)</p>

<div class="language-coq highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
</pre></td><td class="rouge-code"><pre><span class="k">Fixpoint</span><span class="w"> </span><span class="no">In</span><span class="w"> </span><span class="o">{</span><span class="no">A</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="kr">Type</span><span class="o">}</span><span class="w"> </span><span class="o">(</span><span class="no">x</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="no">A</span><span class="o">)</span><span class="w"> </span><span class="o">(</span><span class="no">l</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="no">list</span><span class="w"> </span><span class="no">A</span><span class="o">)</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="kr">Prop</span><span class="w"> </span><span class="p">:=</span><span class="w">
  </span><span class="kr">match</span><span class="w"> </span><span class="no">l</span><span class="w"> </span><span class="kp">with</span><span class="w">
  </span><span class="o">|</span><span class="w"> </span><span class="o">[]</span><span class="w"> </span><span class="p">=&gt;</span><span class="w"> </span><span class="no">False</span><span class="w">
  </span><span class="o">|</span><span class="w"> </span><span class="no">x'</span><span class="w"> </span><span class="o">::</span><span class="w"> </span><span class="no">l'</span><span class="w"> </span><span class="p">=&gt;</span><span class="w"> </span><span class="no">x'</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="no">x</span><span class="w"> </span><span class="err">∨</span><span class="w"> </span><span class="no">In</span><span class="w"> </span><span class="no">x</span><span class="w"> </span><span class="no">l'</span><span class="w">
  </span><span class="kr">end</span><span class="pi">.</span><span class="w">
</span></pre></td></tr></tbody></table></code></pre></div></div>

<p>The whole thing I understood as a <em>type operator</em> (function in type level) and it’s <em>recursive</em>!</p>

<p>Coq dare to do that becuz its <em>total</em>, which is guarded by its <em>termination checker</em>.
un-total PL, if having this, would make its type system <em>Turing Complete</em> (thus having <em>Halting Problem</em>).
(Recursive Type like ADT/GADT in ML/Haskell is a limited form of recursion allowing no arbitray recursion.)</p>

<h3 id="in_map">In_map</h3>

<p>I took this one since it’s like a formal version of <em>Property-based Tests</em>!.</p>

<div class="language-coq highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
</pre></td><td class="rouge-code"><pre><span class="k">Lemma</span><span class="w"> </span><span class="no">In_map</span><span class="w"> </span><span class="p">:</span><span class="w">
  </span><span class="kr">forall</span><span class="w"> </span><span class="o">(</span><span class="no">A</span><span class="w"> </span><span class="no">B</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="kr">Type</span><span class="o">)</span><span class="w"> </span><span class="o">(</span><span class="no">f</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="no">A</span><span class="w"> </span><span class="p">-&gt;</span><span class="w"> </span><span class="no">B</span><span class="o">)</span><span class="w"> </span><span class="o">(</span><span class="no">l</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="no">list</span><span class="w"> </span><span class="no">A</span><span class="o">)</span><span class="w"> </span><span class="o">(</span><span class="no">x</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="no">A</span><span class="o">),</span><span class="w">
    </span><span class="no">In</span><span class="w"> </span><span class="no">x</span><span class="w"> </span><span class="no">l</span><span class="w"> </span><span class="p">-&gt;</span><span class="w">
    </span><span class="no">In</span><span class="w"> </span><span class="o">(</span><span class="no">f</span><span class="w"> </span><span class="no">x</span><span class="o">)</span><span class="w"> </span><span class="o">(</span><span class="no">map</span><span class="w"> </span><span class="no">f</span><span class="w"> </span><span class="no">l</span><span class="o">).</span><span class="w">
</span><span class="k">Proof</span><span class="pi">.</span><span class="w">
  </span><span class="kp">intros</span><span class="w"> </span><span class="no">A</span><span class="w"> </span><span class="no">B</span><span class="w"> </span><span class="no">f</span><span class="w"> </span><span class="no">l</span><span class="w"> </span><span class="no">x</span><span class="pi">.</span><span class="w">
  </span><span class="kp">induction</span><span class="w"> </span><span class="no">l</span><span class="w"> </span><span class="kr">as</span><span class="w"> </span><span class="o">[|</span><span class="no">x'</span><span class="w"> </span><span class="no">l'</span><span class="w"> </span><span class="no">IHl'</span><span class="o">].</span><span class="w">
  </span><span class="o">-</span><span class="w"> </span><span class="c">(* l = nil, contradiction *)</span><span class="w">
    </span><span class="kp">simpl</span><span class="pi">.</span><span class="w"> </span><span class="kp">intros</span><span class="w"> </span><span class="o">[].</span><span class="w">
  </span><span class="o">-</span><span class="w"> </span><span class="c">(* l = x' :: l' *)</span><span class="w">
    </span><span class="kp">simpl</span><span class="pi">.</span><span class="w"> </span><span class="kp">intros</span><span class="w"> </span><span class="o">[</span><span class="no">H</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="no">H</span><span class="o">].</span><span class="w">           </span><span class="c">(* evaluating [In] gives us 2 cases:  *)</span><span class="w">
    </span><span class="o">+</span><span class="w"> </span><span class="kp">rewrite</span><span class="w"> </span><span class="no">H</span><span class="pi">.</span><span class="w"> </span><span class="no">left</span><span class="pi">.</span><span class="w"> </span><span class="ne">reflexivity</span><span class="pi">.</span><span class="w">  </span><span class="c">(* in head of l *)</span><span class="w">
    </span><span class="o">+</span><span class="w"> </span><span class="no">right</span><span class="pi">.</span><span class="w"> </span><span class="kp">apply</span><span class="w"> </span><span class="no">IHl'</span><span class="pi">.</span><span class="w"> </span><span class="kp">apply</span><span class="w"> </span><span class="no">H</span><span class="pi">.</span><span class="w">    </span><span class="c">(* in tail of l*)</span><span class="w">
</span><span class="k">Qed</span><span class="pi">.</span><span class="w">
</span></pre></td></tr></tbody></table></code></pre></div></div>

<blockquote>
  <p>Q &amp; A:</p>
  <ol>
    <li><code class="highlighter-rouge">eq</code> is just another inductively defined and doesn’t have any computational content. (satisfication)</li>
    <li>Why use <code class="highlighter-rouge">Prop</code> instead of <code class="highlighter-rouge">bool</code>? See <em>reflection</em> below.</li>
  </ol>
</blockquote>

<h3 id="drawbacks">Drawbacks</h3>

<blockquote>
  <p>In particular, it is subject to Coq’s usual restrictions regarding the definition of recursive functions, 
e.g., the requirement that they be “obviously terminating.”</p>
</blockquote>

<blockquote>
  <p>In the next chapter, we will see how to define propositions <em>inductively</em>, 
a different technique with its own set of strengths and limitations.</p>
</blockquote>

<h2 id="applying-theorems-to-arguments">Applying Theorems to Arguments.</h2>

<h3 id="check-some_theorem-print-the-statement"><code class="highlighter-rouge">Check some_theorem</code> print the statement!</h3>

<div class="language-coq highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
</pre></td><td class="rouge-code"><pre><span class="k">Check</span><span class="w"> </span><span class="no">plus_comm</span><span class="pi">.</span><span class="w">
</span><span class="c">(* ===&gt; forall n m : nat, n + m = m + n *)</span><span class="w">
</span></pre></td></tr></tbody></table></code></pre></div></div>

<blockquote>
  <p>Coq prints the <em>statement</em> of the <code class="highlighter-rouge">plus_comm</code> theorem in the same way that it prints the <em>type</em> of any term that we ask it to Check. Why?</p>
</blockquote>

<p>Hmm…I just noticed that!!
But I should notice because <strong>Propositions are Types! (and terms are proof)</strong></p>

<h3 id="proof-object">Proof Object</h3>

<blockquote>
  <p><em>proofs</em> as first-class objects.</p>
</blockquote>

<p>After <code class="highlighter-rouge">Qed.</code>, Coq defined they as <em>Proof Object</em> and the <em>type of this obj</em> is the statement of the theorem.</p>

<blockquote>
  <p>Provable: some type is inhabited by some thing (having terms).</p>
</blockquote>

<p>So I guess when we apply theorems, Coq implicitly use the type of the Proof Object. (it’s already type abstraction)
…we will get to there later at ProofObject chapter.</p>

<h3 id="apply-theorem-as-function">Apply theorem as function</h3>

<blockquote>
  <p><code class="highlighter-rouge">rewrite</code> select variables greedily by default</p>
</blockquote>

<div class="language-coq highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
</pre></td><td class="rouge-code"><pre><span class="k">Lemma</span><span class="w"> </span><span class="no">plus_comm3_take3</span><span class="w"> </span><span class="p">:</span><span class="w">
  </span><span class="err">∀</span><span class="no">x</span><span class="w"> </span><span class="no">y</span><span class="w"> </span><span class="no">z</span><span class="o">,</span><span class="w"> </span><span class="no">x</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="o">(</span><span class="no">y</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="no">z</span><span class="o">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">(</span><span class="no">z</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="no">y</span><span class="o">)</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="no">x</span><span class="pi">.</span><span class="w">
</span><span class="k">Proof</span><span class="pi">.</span><span class="w">
  </span><span class="kp">intros</span><span class="w"> </span><span class="no">x</span><span class="w"> </span><span class="no">y</span><span class="w"> </span><span class="no">z</span><span class="pi">.</span><span class="w">
  </span><span class="kp">rewrite</span><span class="w"> </span><span class="no">plus_comm</span><span class="pi">.</span><span class="w">
  </span><span class="kp">rewrite</span><span class="w"> </span><span class="o">(</span><span class="no">plus_comm</span><span class="w"> </span><span class="no">y</span><span class="w"> </span><span class="no">z</span><span class="o">).</span><span class="w">     </span><span class="c">(* we can explicitly provide type var! *)</span><span class="w">
  </span><span class="ne">reflexivity</span><span class="pi">.</span><span class="w">
</span><span class="k">Qed</span><span class="pi">.</span><span class="w">
</span></pre></td></tr></tbody></table></code></pre></div></div>

<p><code class="highlighter-rouge">x y z</code> were some type var and <em>instantiated to values</em> by <code class="highlighter-rouge">intros</code>, e.g. <code class="highlighter-rouge">x, y, z:nat</code> 
but we can explicilty pass in to <code class="highlighter-rouge">plus_comm</code>, which is a forall type abstraction! (<code class="highlighter-rouge">Δ n m. (eq (n + m) (m + n))</code>)</p>

<blockquote>
  <p>there must be something there in Proof Object so we can apply <em>values</em> to a <em>type-level function</em></p>
</blockquote>

<h2 id="coq-vs-set-theory">Coq vs. Set Theory</h2>

<p>Coq’s logical core, <em>the Calculus of Inductive Constructions</em>, is a <em>metalanguage for math</em>, but differs from other foundations of math e.g. ZFC Set Theory</p>

<h3 id="functional-extensionality">Functional Extensionality</h3>

<div class="language-coq highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
</pre></td><td class="rouge-code"><pre><span class="o">(</span><span class="err">∀</span><span class="no">x</span><span class="o">,</span><span class="w"> </span><span class="no">f</span><span class="w"> </span><span class="no">x</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="no">g</span><span class="w"> </span><span class="no">x</span><span class="o">)</span><span class="w"> </span><span class="err">→</span><span class="w"> </span><span class="no">f</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="no">g</span><span class="w">

</span><span class="err">∃</span><span class="no">f</span><span class="w"> </span><span class="no">g</span><span class="o">,</span><span class="w"> </span><span class="o">(</span><span class="err">∀</span><span class="no">x</span><span class="o">,</span><span class="w"> </span><span class="no">f</span><span class="w"> </span><span class="no">x</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="no">g</span><span class="w"> </span><span class="no">x</span><span class="o">)</span><span class="w"> </span><span class="err">→</span><span class="w"> </span><span class="no">f</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="no">g</span><span class="w">

</span><span class="err">∃</span><span class="no">f</span><span class="w"> </span><span class="no">g</span><span class="o">,</span><span class="w"> </span><span class="o">(</span><span class="err">∀</span><span class="no">x</span><span class="o">,</span><span class="w"> </span><span class="no">f</span><span class="w"> </span><span class="no">x</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="no">g</span><span class="w"> </span><span class="no">x</span><span class="o">)</span><span class="w"> </span><span class="err">∧</span><span class="w"> </span><span class="no">f</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="no">g</span><span class="w">    </span><span class="c">(* negation, consistent but not interesting... *)</span><span class="w">
</span></pre></td></tr></tbody></table></code></pre></div></div>

<blockquote>
  <p>In common math practice, two functions <code class="highlighter-rouge">f</code> and <code class="highlighter-rouge">g</code> are considered equal if they produce the same outputs.
This is known as the principle of <em>functional extensionality</em>.</p>
</blockquote>

<blockquote>
  <p>Informally speaking, an “extensional property” is one that pertains to an object’s observable behavior.
<a href="https://en.wikipedia.org/wiki/Extensionality">https://en.wikipedia.org/wiki/Extensionality</a>
<a href="https://en.wikipedia.org/wiki/Extensional_and_intensional_definitions">https://en.wikipedia.org/wiki/Extensional_and_intensional_definitions</a>?</p>
</blockquote>

<p>This is not built-in Coq, but we can add them as Axioms. 
Why not add everything?</p>
<blockquote>
  <ol>
    <li>One or multiple axioms combined might render <em>inconsistency</em>.</li>
    <li>Code extraction might be problematic</li>
  </ol>
</blockquote>

<blockquote>
  <p>Fortunately, it is known that adding functional extensionality, in particular, is consistent.
<a href="https://en.wikipedia.org/wiki/Consistency">consistency</a>:
   a consistent theory is one that does not contain a contradiction.</p>
</blockquote>

<h3 id="adding-axioms">Adding Axioms</h3>

<div class="language-coq highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
</pre></td><td class="rouge-code"><pre><span class="no">Axiom</span><span class="w"> </span><span class="no">functional_extensionality</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="kr">forall</span><span class="w"> </span><span class="o">{</span><span class="no">X</span><span class="w"> </span><span class="no">Y</span><span class="p">:</span><span class="w"> </span><span class="kr">Type</span><span class="o">}</span><span class="w">
                                    </span><span class="o">{</span><span class="no">f</span><span class="w"> </span><span class="no">g</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="no">X</span><span class="w"> </span><span class="p">-&gt;</span><span class="w"> </span><span class="no">Y</span><span class="o">},</span><span class="w">
  </span><span class="o">(</span><span class="kr">forall</span><span class="w"> </span><span class="o">(</span><span class="no">x</span><span class="p">:</span><span class="no">X</span><span class="o">),</span><span class="w"> </span><span class="no">f</span><span class="w"> </span><span class="no">x</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="no">g</span><span class="w"> </span><span class="no">x</span><span class="o">)</span><span class="w"> </span><span class="p">-&gt;</span><span class="w"> </span><span class="no">f</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="no">g</span><span class="pi">.</span><span class="w">
</span></pre></td></tr></tbody></table></code></pre></div></div>

<p>It’s like <code class="highlighter-rouge">Admitted.</code> but alerts we’re not going to fill in later.</p>

<h3 id="exercise---proving-reverse-with-app-and-with-cons-are-fn-exensionally-equivalent">Exercise - Proving Reverse with <code class="highlighter-rouge">app</code> and with <code class="highlighter-rouge">cons</code> are fn-exensionally equivalent.</h3>

<div class="language-coq highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
</pre></td><td class="rouge-code"><pre><span class="k">Fixpoint</span><span class="w"> </span><span class="no">rev_append</span><span class="w"> </span><span class="o">{</span><span class="no">X</span><span class="o">}</span><span class="w"> </span><span class="o">(</span><span class="no">l1</span><span class="w"> </span><span class="no">l2</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="no">list</span><span class="w"> </span><span class="no">X</span><span class="o">)</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="no">list</span><span class="w"> </span><span class="no">X</span><span class="w"> </span><span class="p">:=</span><span class="w">
  </span><span class="kr">match</span><span class="w"> </span><span class="no">l1</span><span class="w"> </span><span class="kp">with</span><span class="w">
  </span><span class="o">|</span><span class="w"> </span><span class="o">[]</span><span class="w"> </span><span class="p">=&gt;</span><span class="w"> </span><span class="no">l2</span><span class="w">
  </span><span class="o">|</span><span class="w"> </span><span class="no">x</span><span class="w"> </span><span class="o">::</span><span class="w"> </span><span class="no">l1'</span><span class="w"> </span><span class="p">=&gt;</span><span class="w"> </span><span class="no">rev_append</span><span class="w"> </span><span class="no">l1'</span><span class="w"> </span><span class="o">(</span><span class="no">x</span><span class="w"> </span><span class="o">::</span><span class="w"> </span><span class="no">l2</span><span class="o">)</span><span class="w">
  </span><span class="kr">end</span><span class="pi">.</span><span class="w">

</span><span class="k">Definition</span><span class="w"> </span><span class="no">tr_rev</span><span class="w"> </span><span class="o">{</span><span class="no">X</span><span class="o">}</span><span class="w"> </span><span class="o">(</span><span class="no">l</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="no">list</span><span class="w"> </span><span class="no">X</span><span class="o">)</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="no">list</span><span class="w"> </span><span class="no">X</span><span class="w"> </span><span class="p">:=</span><span class="w">
  </span><span class="no">rev_append</span><span class="w"> </span><span class="no">l</span><span class="w"> </span><span class="o">[].</span><span class="w">
</span></pre></td></tr></tbody></table></code></pre></div></div>

<p>BTW, this version is <code class="highlighter-rouge">tail recursive</code> becuz the recursive call is the last operation needs to performed.
(In <code class="highlighter-rouge">rev</code> i.e. <code class="highlighter-rouge">rev t ++ [h]</code>, recursive call is a argument of function <code class="highlighter-rouge">++</code> and we are CBV.)</p>

<div class="language-coq highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre></td><td class="rouge-code"><pre><span class="k">Lemma</span><span class="w"> </span><span class="no">tr_rev_correct</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="kr">forall</span><span class="w"> </span><span class="no">X</span><span class="o">,</span><span class="w"> </span><span class="o">@</span><span class="no">tr_rev</span><span class="w"> </span><span class="no">X</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">@</span><span class="no">rev</span><span class="w"> </span><span class="no">X</span><span class="pi">.</span><span class="w">
</span></pre></td></tr></tbody></table></code></pre></div></div>

<h3 id="propositions-and-booleans">Propositions and Booleans</h3>

<blockquote>
  <p>We’ve seen two different ways of expressing logical claims in Coq:</p>
  <ol>
    <li>with booleans     (of type <code class="highlighter-rouge">bool</code>),  ; computational way</li>
    <li>with propositions (of type <code class="highlighter-rouge">Prop</code>).  ; logical way</li>
  </ol>
</blockquote>

<p>There’re two ways to define 42 is even:</p>

<div class="language-coq highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
</pre></td><td class="rouge-code"><pre><span class="k">Example</span><span class="w"> </span><span class="no">even_42_bool</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="no">evenb</span><span class="w"> </span><span class="mi">42</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="no">true</span><span class="pi">.</span><span class="w">
</span><span class="k">Example</span><span class="w"> </span><span class="no">even_42_prop</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="err">∃</span><span class="no">k</span><span class="o">,</span><span class="w"> </span><span class="mi">42</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="no">double</span><span class="w"> </span><span class="no">k</span><span class="pi">.</span><span class="w">
</span></pre></td></tr></tbody></table></code></pre></div></div>

<p>We wanna show there are <em>interchangable</em>.</p>

<div class="language-coq highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
</pre></td><td class="rouge-code"><pre><span class="k">Theorem</span><span class="w"> </span><span class="no">even_bool_prop</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="err">∀</span><span class="no">n</span><span class="o">,</span><span class="w">
  </span><span class="no">evenb</span><span class="w"> </span><span class="no">n</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="no">true</span><span class="w"> </span><span class="err">↔</span><span class="w"> </span><span class="err">∃</span><span class="no">k</span><span class="o">,</span><span class="w"> </span><span class="no">n</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="no">double</span><span class="w"> </span><span class="no">k</span><span class="pi">.</span><span class="w">
</span></pre></td></tr></tbody></table></code></pre></div></div>

<blockquote>
  <p>In view of this theorem, we say that the 
boolean computation <code class="highlighter-rouge">evenb n</code> <em>reflects</em> the truth of the proposition <code class="highlighter-rouge">∃ k, n = double k</code>.</p>
</blockquote>

<p>We can futhur general this to any equations representing as <code class="highlighter-rouge">bool</code> or <code class="highlighter-rouge">Prop</code>:</p>

<div class="language-coq highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
</pre></td><td class="rouge-code"><pre><span class="k">Theorem</span><span class="w"> </span><span class="no">eqb_eq</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="err">∀</span><span class="no">n1</span><span class="w"> </span><span class="no">n2</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="no">nat</span><span class="o">,</span><span class="w">
  </span><span class="no">n1</span><span class="w"> </span><span class="o">=?</span><span class="w"> </span><span class="no">n2</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="no">true</span><span class="w"> </span><span class="err">↔</span><span class="w"> </span><span class="no">n1</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="no">n2</span><span class="pi">.</span><span class="w">
</span></pre></td></tr></tbody></table></code></pre></div></div>

<h4 id="notes-on-computability">Notes on Computability.</h4>

<blockquote>
  <p>However, even they are equivalent from a purely logical perspective, 
they may not be equivalent <code class="highlighter-rouge">operationally</code>.</p>
</blockquote>

<div class="language-coq highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
</pre></td><td class="rouge-code"><pre><span class="no">Fail</span><span class="w"> </span><span class="k">Definition</span><span class="w"> </span><span class="no">is_even_prime</span><span class="w"> </span><span class="no">n</span><span class="w"> </span><span class="p">:=</span><span class="w">
  </span><span class="kr">if</span><span class="w"> </span><span class="no">n</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">2</span><span class="w"> </span><span class="kr">then</span><span class="w"> </span><span class="no">true</span><span class="w">
  </span><span class="kr">else</span><span class="w"> </span><span class="no">false</span><span class="pi">.</span><span class="w">

</span><span class="no">Error</span><span class="p">:</span><span class="w"> </span><span class="no">The</span><span class="w"> </span><span class="no">term</span><span class="w"> </span><span class="s2">"n = 2"</span><span class="w"> </span><span class="no">has</span><span class="w"> </span><span class="no">type</span><span class="w"> </span><span class="s2">"Prop"</span><span class="w"> </span><span class="no">which</span><span class="w"> </span><span class="no">is</span><span class="w"> </span><span class="no">not</span><span class="w"> </span><span class="no">a</span><span class="w"> </span><span class="o">(</span><span class="no">co</span><span class="o">-)</span><span class="no">inductive</span><span class="w"> </span><span class="no">type</span><span class="pi">.</span><span class="w">
</span></pre></td></tr></tbody></table></code></pre></div></div>

<p><code class="highlighter-rouge">=</code>, or <code class="highlighter-rouge">eq</code>, as any function in Coq, need to be computable and total. And we have no way to tell <em>whether any given proposition is true or false</em>. (…We can only naturally deduce things are inductively defined)</p>

<blockquote>
  <p>As a consequence, Prop in Coq does not have a universal case analysis operation telling whether any given proposition is true or false, since such an operation would allow us to write non-computable functions.</p>
</blockquote>

<blockquote>
  <p>Although general non-computable properties cannot be phrased as boolean computations, it is worth noting that even many computable properties are easier to express using Prop than bool, since recursive function definitions are subject to significant restrictions in Coq.</p>
</blockquote>

<p>E.g. Verifying Regular Expr in next chapter.</p>
<blockquote>
  <p>Doing the same with <code class="highlighter-rouge">bool</code> would amount to writing a <em>full regular expression matcher</em> (so we can execute the regex).</p>
</blockquote>

<h4 id="proof-by-reflection">Proof by Reflection!</h4>

<div class="language-coq highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
</pre></td><td class="rouge-code"><pre><span class="c">(* Logically *)</span><span class="w">
</span><span class="k">Example</span><span class="w"> </span><span class="no">even_1000</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="err">∃</span><span class="no">k</span><span class="o">,</span><span class="w"> </span><span class="mi">1000</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="no">double</span><span class="w"> </span><span class="no">k</span><span class="pi">.</span><span class="w">
</span><span class="k">Proof</span><span class="pi">.</span><span class="w"> </span><span class="err">∃</span><span class="mi">500</span><span class="o">.</span><span class="w"> </span><span class="ne">reflexivity</span><span class="pi">.</span><span class="w"> </span><span class="k">Qed</span><span class="pi">.</span><span class="w">

</span><span class="c">(* Computationally *)</span><span class="w">
</span><span class="k">Example</span><span class="w"> </span><span class="no">even_1000'</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="no">evenb</span><span class="w"> </span><span class="mi">1000</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="no">true</span><span class="pi">.</span><span class="w">
</span><span class="k">Proof</span><span class="pi">.</span><span class="w"> </span><span class="ne">reflexivity</span><span class="pi">.</span><span class="w"> </span><span class="k">Qed</span><span class="pi">.</span><span class="w">

</span><span class="c">(* Prove logical version by reflecting in computational version *)</span><span class="w">
</span><span class="k">Example</span><span class="w"> </span><span class="no">even_1000''</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="err">∃</span><span class="no">k</span><span class="o">,</span><span class="w"> </span><span class="mi">1000</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="no">double</span><span class="w"> </span><span class="no">k</span><span class="pi">.</span><span class="w">
</span><span class="k">Proof</span><span class="pi">.</span><span class="w"> </span><span class="kp">apply</span><span class="w"> </span><span class="no">even_bool_prop</span><span class="pi">.</span><span class="w"> </span><span class="ne">reflexivity</span><span class="pi">.</span><span class="w"> </span><span class="k">Qed</span><span class="pi">.</span><span class="w">
</span></pre></td></tr></tbody></table></code></pre></div></div>

<blockquote>
  <p>As an extreme example, the Coq proof of the famous <em>4-color theorem</em> uses reflection to reduce the analysis of hundreds of different cases to a boolean computation.</p>
</blockquote>

<h3 id="classical-vs-constructive-logic">Classical vs. Constructive Logic</h3>

<p>…</p>

<h2 id="future-schedule">Future Schedule</h2>

<blockquote>
  <p>Proof got messier!
Lean on your past PLT experience</p>
</blockquote>

<p>As discussion leader</p>

<ul>
  <li>having many materials now</li>
  <li>selected troublesome and interesting ones</li>
</ul>



                <hr style="visibility: hidden;">
                <ul class="pager">
                    
                    <li class="previous">
                        <a href="/2019/01/05/sf-lf-05-tactics/" data-toggle="tooltip" data-placement="top" title="「SF-LC」5 Tactics">
                        Previous<br>
                        <span>「SF-LC」5 Tactics</span>
                        </a>
                    </li>
                    
                    
                    <li class="next">
                        <a href="/2019/01/07/sf-lf-07-indprop/" data-toggle="tooltip" data-placement="top" title="「SF-LC」7 Ind Prop">
                        Next<br>
                        <span>「SF-LC」7 Ind Prop</span>
                        </a>
                    </li>
                    
                </ul>
                <hr style="visibility: hidden;">

                
                <!-- disqus 评论框 start -->
                <div class="comment">
                    <div id="disqus_thread" class="disqus-thread"></div>
                </div>
                <!-- disqus 评论框 end -->
                

                
            </div>  

    <!-- Side Catalog Container -->
        

    <!-- Sidebar Container -->
            <div class="
                col-lg-8 col-lg-offset-2
                col-md-10 col-md-offset-1
                sidebar-container">

                <!-- Featured Tags -->
                


<section>
    
        <hr class="hidden-sm hidden-xs">
    
    <h5><a href="/archive/">FEATURED TAGS</a></h5>
    <div class="tags">
        
        
        
        </a>
        
        
                <a data-sort="0065" 
                    href="/archive/?tag=%E7%9F%A5%E4%B9%8E"
                    title="知乎"
                    rel="10">知乎</a>
        
                <a data-sort="0036" 
                    href="/archive/?tag=%E7%AC%94%E8%AE%B0"
                    title="笔记"
                    rel="39">笔记</a>
        
                <a data-sort="0039" 
                    href="/archive/?tag=Coq"
                    title="Coq"
                    rel="36">Coq</a>
        
                <a data-sort="0039" 
                    href="/archive/?tag=SF+%28%E8%BD%AF%E4%BB%B6%E5%9F%BA%E7%A1%80%29"
                    title="SF (软件基础)"
                    rel="36">SF (软件基础)</a>
        
                <a data-sort="0056" 
                    href="/archive/?tag=PLF+%28%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80%29"
                    title="PLF (编程语言基础)"
                    rel="19">PLF (编程语言基础)</a>
        
                <a data-sort="0056" 
                    href="/archive/?tag=Web"
                    title="Web"
                    rel="19">Web</a>
        
                <a data-sort="0059" 
                    href="/archive/?tag=LF+%28%E9%80%BB%E8%BE%91%E5%9F%BA%E7%A1%80%29"
                    title="LF (逻辑基础)"
                    rel="16">LF (逻辑基础)</a>
        
                <a data-sort="0068" 
                    href="/archive/?tag=UX%2FUI"
                    title="UX/UI"
                    rel="7">UX/UI</a>
        
                <a data-sort="0069" 
                    href="/archive/?tag=%E4%BA%A7%E5%93%81"
                    title="产品"
                    rel="6">产品</a>
        
                <a data-sort="0069" 
                    href="/archive/?tag=PWA"
                    title="PWA"
                    rel="6">PWA</a>
        
                <a data-sort="0071" 
                    href="/archive/?tag=JavaScript"
                    title="JavaScript"
                    rel="4">JavaScript</a>
        
                <a data-sort="0071" 
                    href="/archive/?tag=Slides"
                    title="Slides"
                    rel="4">Slides</a>
        
                <a data-sort="0072" 
                    href="/archive/?tag=%E7%94%9F%E6%B4%BB"
                    title="生活"
                    rel="3">生活</a>
        
                <a data-sort="0072" 
                    href="/archive/?tag=%E8%AF%91"
                    title="译"
                    rel="3">译</a>
        
                <a data-sort="0072" 
                    href="/archive/?tag=%E9%98%BF%E9%87%8C"
                    title="阿里"
                    rel="3">阿里</a>
        
                <a data-sort="0072" 
                    href="/archive/?tag=%F0%9F%87%AC%F0%9F%87%A7"
                    title="🇬🇧"
                    rel="3">🇬🇧</a>
        
                <a data-sort="0072" 
                    href="/archive/?tag=Vim"
                    title="Vim"
                    rel="3">Vim</a>
        
                <a data-sort="0073" 
                    href="/archive/?tag=%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6"
                    title="计算机科学"
                    rel="2">计算机科学</a>
        
                <a data-sort="0073" 
                    href="/archive/?tag=%E8%AE%A1%E7%AE%97%E7%90%86%E8%AE%BA"
                    title="计算理论"
                    rel="2">计算理论</a>
        
                <a data-sort="0073" 
                    href="/archive/?tag=CSS"
                    title="CSS"
                    rel="2">CSS</a>
        
                <a data-sort="0073" 
                    href="/archive/?tag=Wechat"
                    title="Wechat"
                    rel="2">Wechat</a>
        
                <a data-sort="0073" 
                    href="/archive/?tag=hUX+%E9%9A%8F%E6%83%B3%E5%BD%95"
                    title="hUX 随想录"
                    rel="2">hUX 随想录
    </div>
</section>


                <!-- Friends Blog -->
                
<hr>
<h5>FRIENDS</h5>
<ul class="list-inline">
  
  <li><a href="http://mida.re/">乱序</a></li>
  
  <li><a href="http://qianduan.guru/">前端外刊评论</a></li>
  
  <li><a href="http://lingyu.wang/">天镶的博客</a></li>
  
  <li><a href="http://hmqk1995.github.io">Luke 的自留地</a></li>
  
  <li><a href="http://ebnbin.com/">Ebn's Blog</a></li>
  
  <li><a href="http://blog.smdcn.net">SmdCn's Blog</a></li>
  
  <li><a href="https://www.ruoyaowu.com/">David's Game</a></li>
  
  <li><a href="http://dhong.co">DHong Say</a></li>
  
  <li><a href="http://ingf.github.io/">尹峰以为</a></li>
  
  <li><a href="http://xieminis.me/">解旻的博客</a></li>
  
</ul>

            </div>
        </div>
    </div>
</article>

<!-- add support for mathjax by voleking-->






<!-- disqus 公共JS代码 start (一个网页只需插入一次) -->
<script type="text/javascript">
    /* * * CONFIGURATION VARIABLES * * */
    var disqus_shortname = "hux";
    var disqus_identifier = "/2019/01/06/sf-lf-06-logic";
    var disqus_url = "http://localhost:4000/2019/01/06/sf-lf-06-logic/";

    (function() {
        var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
        dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
        (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
    })();
</script>
<!-- disqus 公共JS代码 end -->




<!-- async load function -->
<script>
    function async(u, c) {
      var d = document, t = 'script',
          o = d.createElement(t),
          s = d.getElementsByTagName(t)[0];
      o.src = u;
      if (c) { o.addEventListener('load', function (e) { c(null, e); }, false); }
      s.parentNode.insertBefore(o, s);
    }
</script>
<!-- anchor-js, Doc:http://bryanbraun.github.io/anchorjs/ -->
<script>
    async("//cdnjs.cloudflare.com/ajax/libs/anchor-js/1.1.1/anchor.min.js",function(){
        anchors.options = {
          visible: 'hover',
          placement: 'right',
          // icon: '#'
        };
        anchors.add().remove('.intro-header h1').remove('.subheading').remove('.sidebar-container h5');
    })
</script>
<style>
    /* place left on bigger screen */
    @media all and (min-width: 800px) {
        .anchorjs-link{
            position: absolute;
            left: -0.75em;
            font-size: 1.1em;
            margin-top : -0.1em;
        }
    }
</style>



    <!-- Footer -->
<footer>
    <div class="container">
        <div class="row">
            <div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1">
                <!-- SNS Link -->
                


<ul class="list-inline text-center">


  
  
  <li>
    <a href="https://twitter.com/huxpro">
      <span class="fa-stack fa-lg">
        <i class="fa fa-circle fa-stack-2x"></i>
        <i class="fa fa-twitter fa-stack-1x fa-inverse"></i>
      </span>
    </a>
  </li>
  
  
  <li>
    <a target="_blank" href="https://www.zhihu.com/people/huxpro">
      <span class="fa-stack fa-lg">
        <i class="fa fa-circle fa-stack-2x"></i>
        <i class="fa  fa-stack-1x fa-inverse">知</i>
      </span>
    </a>
  </li>
  
  
  <li>
    <a target="_blank" href="http://weibo.com/huxpro">
      <span class="fa-stack fa-lg">
        <i class="fa fa-circle fa-stack-2x"></i>
        <i class="fa fa-weibo fa-stack-1x fa-inverse"></i>
      </span>
    </a>
  </li>
  
  
  
  <li>
    <a target="_blank" href="https://github.com/huxpro">
      <span class="fa-stack fa-lg">
        <i class="fa fa-circle fa-stack-2x"></i>
        <i class="fa fa-github fa-stack-1x fa-inverse"></i>
      </span>
    </a>
  </li>
  
  
</ul>

                <p class="copyright text-muted">
                    Copyright &copy; lxd's Blog 2019
                    <br>
                    Powered by <a href="http://huangxuan.me">Hux Blog</a> |
                    <iframe
                        style="margin-left: 2px; margin-bottom:-5px;"
                        frameborder="0" scrolling="0" width="100px" height="20px"
                        src="https://ghbtns.com/github-btn.html?user=huxpro&repo=huxpro.github.io&type=star&count=true" >
                    </iframe>
                </p>
            </div>
        </div>
    </div>
</footer>

<!-- jQuery -->
<script src="/js/jquery.min.js "></script>

<!-- Bootstrap Core JavaScript -->
<!-- Currently, only navbar scroll-down effect at desktop still depends on this -->
<script src="/js/bootstrap.min.js "></script>

<!-- Custom Theme JavaScript -->
<script src="/js/hux-blog.min.js "></script>

<!-- Service Worker -->

<script src="/js/snackbar.js "></script>
<script src="/js/sw-registration.js "></script>


<!-- async load function -->
<script>
    function async(u, c) {
      var d = document, t = 'script',
          o = d.createElement(t),
          s = d.getElementsByTagName(t)[0];
      o.src = u;
      if (c) { o.addEventListener('load', function (e) { c(null, e); }, false); }
      s.parentNode.insertBefore(o, s);
    }
</script>

<!--
     Because of the native support for backtick-style fenced code blocks
     right within the Markdown is landed in Github Pages,
     From V1.6, There is no need for Highlight.js,
     so Huxblog drops it officially.

     - https://github.com/blog/2100-github-pages-now-faster-and-simpler-with-jekyll-3-0
     - https://help.github.com/articles/creating-and-highlighting-code-blocks/
     - https://github.com/jneen/rouge/wiki/list-of-supported-languages-and-lexers
-->
<!--
    <script>
        async("http://cdn.bootcss.com/highlight.js/8.6/highlight.min.js", function(){
            hljs.initHighlightingOnLoad();
        })
    </script>
    <link href="http://cdn.bootcss.com/highlight.js/8.6/styles/github.min.css" rel="stylesheet">
-->





<!--fastClick.js -->
<script>
    async("//cdnjs.cloudflare.com/ajax/libs/fastclick/1.0.6/fastclick.min.js", function(){
        var $nav = document.querySelector("nav");
        if($nav) FastClick.attach($nav);
    })
</script>


<!-- Google Analytics -->

<script>
    // dynamic User by Hux
    var _gaId = 'UA-49627206-1';
    var _gaDomain = 'huangxuan.me';

    // Originial
    (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
    (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
    m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
    })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

    ga('create', _gaId, _gaDomain);
    ga('send', 'pageview');
</script>



<!-- Baidu Tongji -->



<!-- Side Catalog -->



<!-- Multi-Lingual -->




<!-- Image to hack wechat -->
<img src="/img/icon_wechat.png" width="0" height="0" />
<!-- Migrate from head to bottom, no longer block render and still work -->

</body>

</html>
